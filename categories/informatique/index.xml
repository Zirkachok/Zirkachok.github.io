<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Informatique on Zirka</title>
    <link>https://zirkachok.github.io/categories/informatique/index.xml</link>
    <description>Recent content in Informatique on Zirka</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <copyright>Julien Beaudaux. Written in [Go](https://golang.org/), powered by [Hugo](//gohugo.io).</copyright>
    <atom:link href="https://zirkachok.github.io/categories/informatique/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LFCS : Système de fichiers et liens</title>
      <link>https://zirkachok.github.io/2017/04/11/lfcs--syst%C3%A8me-de-fichiers-et-liens</link>
      <pubDate>Tue, 11 Apr 2017 15:59:20 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/04/11/lfcs--syst%C3%A8me-de-fichiers-et-liens</guid>
      <description>

&lt;!-- ê î ô û --&gt;

&lt;p&gt;On dit souvent que sous Unix et Linux&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, &amp;ldquo;tout est fichier&amp;rdquo;, car les répertoires, fichiers réguliers, etc. y sont représentés par des fichiers dont seul le type et le contenu changent. Dans cet article, nous allons vois plus en détail ce qu&amp;rsquo;il en est vraiment, et découvrir un autre type de fichier, les liens.&lt;/p&gt;

&lt;p&gt;Pour illustrer ces concepts pas toujours évidents à appréhender, je vous ai aussi préparé une analogie simple et facile à retenir : la bibliothèque.&lt;/p&gt;

&lt;!-- En fait, tout est représenté pour l&#39;utilisateur par des fichiers. Nous verrons plus en détail ce que cela implique dans un prochain article.  --&gt;

&lt;h1 id=&#34;tout-est-fichier&#34;&gt;Tout est fichier&lt;/h1&gt;

&lt;h2 id=&#34;représentation-des-fichiers&#34;&gt;Représentation des fichiers&lt;/h2&gt;

&lt;p&gt;Sous Linux, un fichier est représenté par son nom et ce qu&amp;rsquo;on appelle un &lt;strong&gt;Inode&lt;/strong&gt;. Un Inode est un espace mémoire contenant les informations essentielles du fichier (ses attributs), à savoir :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;son &lt;strong&gt;type&lt;/strong&gt; : &lt;em&gt;-&lt;/em&gt; pour un fichier régulier, &lt;em&gt;d&lt;/em&gt; pour un dossier, &lt;em&gt;l&lt;/em&gt; pour un lien, etc.&lt;/li&gt;
&lt;li&gt;le &lt;strong&gt;nombre de ses liens physiques&lt;/strong&gt; : il s&amp;rsquo;agit du nombre de noms désignant cet Inode.&lt;/li&gt;
&lt;li&gt;sa &lt;strong&gt;taille&lt;/strong&gt; : l&amp;rsquo;espace mémoire que le contenu du fichier lui-même occupe.&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;&lt;strong&gt;addresse mémoire&lt;/strong&gt; se son contenu.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;et d&amp;rsquo;autres informations comme :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;l&amp;rsquo;identifiant du propriétaire du fichier (UID) et du du groupe auquel appartient le fichier (GID).&lt;/li&gt;
&lt;li&gt;ses droits d&amp;rsquo;accès : plus à ce sujet dans mon articles sur les &lt;em&gt;utilisateurs et droits&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;son horodatage (dernier accès &lt;em&gt;atime&lt;/em&gt;, modification &lt;em&gt;mtime&lt;/em&gt;, et modification de l&amp;rsquo;inode &lt;em&gt;ctime&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ainsi, un répertoire est considéré comme tout autre fichier régulier, à ceci près que son &lt;em&gt;type&lt;/em&gt; est différent (&lt;em&gt;d&lt;/em&gt; dans ce cas). Aussi, le &amp;ldquo;contenu&amp;rdquo; d&amp;rsquo;un répertoire est une table d&amp;rsquo;association entre des noms (les fichiers contenus dans le répertoire) et des inodes. De la même manière, un dispositif de communication (un périphérique ou du matériel, par exemple) sera lui aussi représenté par un fichier (de type &lt;em&gt;p&lt;/em&gt;), etc. Il est possible d&amp;rsquo;utiliser la commande &lt;strong&gt;ls&lt;/strong&gt; avec l&amp;rsquo;option &lt;strong&gt;-i&lt;/strong&gt; pour obtenir le numéro d&amp;rsquo;inode d&amp;rsquo;un fichier.&lt;/p&gt;

&lt;p&gt;Pour l&amp;rsquo;utilisateur, tout est donc représenté par des fichiers&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, qui suivent une certaine organisation : le système de fichier.&lt;/p&gt;

&lt;h2 id=&#34;le-système-de-fichiers&#34;&gt;Le système de fichiers&lt;/h2&gt;

&lt;p&gt;Le système de fichier est une représentation de l&amp;rsquo;arborescence, stockée en mémoire selon une certaine norme. Sous Linux, le système de fichiers contient un index de l&amp;rsquo;ensemble des inodes, suivi du contenu de contenu de chaque inode. L&amp;rsquo;inode 2 est la racine de l&amp;rsquo;arborescence[^3], et il est facile à partir de là d&amp;rsquo;en déduire récursivement l&amp;rsquo;ensemble de l&amp;rsquo;arborescence. C&amp;rsquo;est le principe défini par la norme &lt;strong&gt;Ext&lt;/strong&gt; (pour &lt;em&gt;Extended File System&lt;/em&gt;), dont la version la plus récente est l&amp;rsquo;&lt;strong&gt;Ext4&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il existe bien d&amp;rsquo;autres normes de systèmes de fichiers, chacune ayant ses spécificités. Les plus courantes sont &lt;strong&gt;FAT&lt;/strong&gt; (pour &lt;em&gt;File Allocation Table&lt;/em&gt;), &lt;strong&gt;NTFS&lt;/strong&gt; (pour &lt;em&gt;New Technology File System&lt;/em&gt;, utilisé par les systèmes Windows) et bien sûr &lt;strong&gt;Ext2&lt;/strong&gt;, &lt;strong&gt;Ext3&lt;/strong&gt; et &lt;strong&gt;Ext4&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Plusieurs systèmes de fichiers peuvent être &amp;ldquo;&lt;em&gt;montés&lt;/em&gt;&amp;rdquo; sur dans l&amp;rsquo;arborescence, et peuvent être listés à l&amp;rsquo;aide de la commande &lt;strong&gt;df -T&lt;/strong&gt;. Nous verrons plus en détail dans un autre article comment monter, démonter et gérer ces différents systèmes de fichiers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ df -T
Sys. de fichiers             Type       blocs de 1K    Utilisé Disponible Uti% Monté sur
udev                         devtmpfs       1942644          0    1942644   0% /dev
tmpfs                        tmpfs           391780       6224     385556   2% /run
/dev/sda7                    ext4          57542652   47442952    7153652  87% /
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;!--
Ref : http://www.linux-france.org/article/dalox/unix02.htm
      http://zero202.free.fr/cs3-svsf/html/ar01s02.html
      https://doc.ubuntu-fr.org/systeme_de_fichiers
      http://www.linux-france.org/article/kafkafr/node19.html
      http://formation-debian.via.ecp.fr/filesystem.html
      https://fr.wikipedia.org/wiki/N%C5%93ud_d%27index
      https://forum.ubuntu-fr.org/viewtopic.php?id=282989
      http://www.funix.org/fr/unix/fichiers.htm
--&gt;

&lt;h1 id=&#34;les-liens&#34;&gt;Les liens&lt;/h1&gt;

&lt;p&gt;Maintenant qua nous avons vu ce que sont les inodes et comment ils sont gérés, nous pouvons aborder le concept de &lt;strong&gt;liens&lt;/strong&gt;. Un lien est un type de fichier spécifique, qui sert d&amp;rsquo;alias pour un autre. Il fait donc référence à ce dernier, situé ailleurs dans le système de fichiers. En pratique, il existe deux types de liens : les &lt;strong&gt;liens physiques&lt;/strong&gt; (&lt;em&gt;hard links&lt;/em&gt; en Anglais), et les &lt;strong&gt;liens symboliques&lt;/strong&gt; (&lt;em&gt;soft links&lt;/em&gt;, &lt;em&gt;symbolic links&lt;/em&gt; ou &lt;em&gt;symlinks&lt;/em&gt; en Anglais). Voyons-en les particularités.&lt;/p&gt;

&lt;h2 id=&#34;liens-physiques&#34;&gt;Liens physiques&lt;/h2&gt;

&lt;p&gt;Un fichier de lien physique et le fichier régulier auquel il est lié sont tous deux associés au &lt;strong&gt;même inode&lt;/strong&gt;. Ainsi, la suppression d&amp;rsquo;un de ces deux fichiers ne détruira pas l&amp;rsquo;autre (l&amp;rsquo;inode sera toujours accessible tant qu&amp;rsquo;un nom de fichier y est associé), et la modification de l&amp;rsquo;un entrainera la modification de l&amp;rsquo;autre (car ce sont les données dont l&amp;rsquo;addresse est contenue dans l&amp;rsquo;inode qui sont alors modifiées).&lt;/p&gt;

&lt;p&gt;Dans la pratique, c&amp;rsquo;est la commande &lt;strong&gt;ln&lt;/strong&gt; qui permet de créer des liens (les lignes commencant par &lt;strong&gt;#&lt;/strong&gt; sont des commentaires) :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat hell.txt
Living easy, living free
Season ticket on a one-way ride
[...]

$ ln hell.txt hell_link.txt

$ ls -i
666 hell.txt  666 hell_link.txt

cat hell_link.txt
Living easy, living free
Season ticket on a one-way ride
[...]

# Imagineons que l&#39;on change maintenant le contenu de hell.txt
$ cat hell.txt
No stop signs, speed limit
Nobody is gonna slow me down
[...]

$ cat hell_link.txt
No stop signs, speed limit
Nobody is gonna slow me down
[...]

$ rm hell.txt

$cat hell_link.txt
No stop signs, speed limit
Nobody gonna slow me down
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;liens-symboliques&#34;&gt;Liens symboliques&lt;/h2&gt;

&lt;p&gt;Au contraire, un lien symbolique ressemble plutôt à un raccourci. Un fichier de lien sybolique symbolique aura son inode distinct, dont l&amp;rsquo;addresse vers le contenu désignera l&amp;rsquo;inode du fichier auquel il est lié, et non plus son contenu. Ainsi, détruire le fichier original rendra la lecture ou la modification du lien symbolique impossible.&lt;/p&gt;

&lt;p&gt;Là encore, c&amp;rsquo;est la commande &lt;strong&gt;ln&lt;/strong&gt; qui crée des liens, qui seront des liens symboliques avec l&amp;rsquo;option &lt;strong&gt;-s&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat hell.txt
Living easy, living free
Season ticket on a one-way ride
[...]

$ ln -s hell.txt hell_link.txt

$ ls -i
666 hell.txt  426 hell_link.txt

cat hell_link.txt
Living easy, living free
Season ticket on a one-way ride
[...]

# Imagineons que l&#39;on change maintenant le contenu de hell.txt
$ cat hell.txt
No stop signs, speed limit
Nobody is gonna slow me down
[...]

$ cat hell_link.txt
No stop signs, speed limit
Nobody is gonna slow me down
[...]

$ rm hell.txt

$cat hell_link.txt
cat: hell_link.txt: Aucun fichier ou dossier de ce type
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;l-analogie-de-la-bibliothèque&#34;&gt;L&amp;rsquo;analogie de la bibliothèque&lt;/h1&gt;

&lt;p&gt;Un moyen simple de comprendre le fonctionnement d&amp;rsquo;un système de fichiers est d&amp;rsquo;en faire l&amp;rsquo;analogie avec un bibliothèque. La bibliothèque dispose d&amp;rsquo;un index classant les fiches de chaque livre disponible. Une fiche décrit sommairement le livre (le genre littéraire, le nombre de pages) et en contient l&amp;rsquo;emplacement dans la bibliothèque. Vous l&amp;rsquo;aurez compris, notre bibliothèque représente le système de fichiers, et les fiches sont nos inodes (dont le contenu est d&amp;rsquo;ailleurs similaire).&lt;/p&gt;

&lt;p&gt;Un même livre peut être désigné par deux fiches distinctes. Dans ce cas, la destruction d&amp;rsquo;une des fiche n&amp;rsquo;impacte pas l&amp;rsquo;autre (le livre n&amp;rsquo;a pas changé de place ou de contenu, l&amp;rsquo;autre fiche est donc toujours valide). C&amp;rsquo;est sur ce modèle que fonctionnent les liens physiques.
Une fiche peut aussi renvoyer à une autre fiche existante. Dans ce cas, la destruction de cette dernière rendra la première invalide (car à partir de la référence, on ne pourra plus trouver le livre). C&amp;rsquo;est ainsi que fonctionnent les liens symboliques.&lt;/p&gt;

&lt;!-- 
un symlink c&#39;est different dans le sens ou, le fichier original va pointer sur l&#39;inode contenant la data,
et le symlink va pointer lui sur un inode dont la data correspond au chemin du fichier original !
ce qui fais que lorsque tu détruit le fichier original, le symlink est cassé !  --&gt;

&lt;!-- uname -a --&gt;

&lt;!-- Linux Epinet 3.13.0-93-generic #140-Ubuntu SMP Mon Jul 18 21:21:05 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux --&gt;

&lt;!--   A      B         C                                D                          E      F      G      H      --&gt;

&lt;!-- A = kernel name ; B = network node hostname ; C = kernel release ; D = kernel version ; E = machine hardware name --&gt;

&lt;!-- F = processor type (non-portable) ; G = hardware platform (non-portable) ; H = operating system --&gt;

&lt;!-- shutdown --&gt;

&lt;!-- logout --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Dans cet article, je généraliserai Unix et Linux en ne désignant que Linux, mais tous deux suivent la même philosophie.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Le noyau Linux quant à lui gère les choses différemment, mais c&amp;rsquo;est une toute autre question.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Effectuer des recherches dans l&#39;arborescence</title>
      <link>https://zirkachok.github.io/2017/04/10/lfcs--effectuer-des-recherches-dans-larborescence</link>
      <pubDate>Mon, 10 Apr 2017 13:48:16 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/04/10/lfcs--effectuer-des-recherches-dans-larborescence</guid>
      <description>&lt;!-- ê î ô --&gt;

&lt;p&gt;À ce stade là, nous savons déjà faire beaucoup de choses pour manipuler l&amp;rsquo;arborescence. Reste que lorsqu&amp;rsquo;on cherche un fichier précis sans savoir où il se trouve exactement, les choses se compliquent. C&amp;rsquo;est là que la commande &lt;strong&gt;locate&lt;/strong&gt; entre en jeu. Avec en argument un ou plusieurs motif(s), elle permet de lister tous les chemins contenant un des motifs en question. Quelques options permettent d&amp;rsquo;affiner ces recherches :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-i&lt;/strong&gt; ou &lt;strong&gt;--ignore-case&lt;/strong&gt; : De base, locate est sensible à la casse. L&amp;rsquo;option &lt;em&gt;-i&lt;/em&gt; enlève cette restriction.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-c&lt;/strong&gt; ou &lt;strong&gt;--count&lt;/strong&gt; : Plutôt que de lister les fichiers trouver, &lt;em&gt;locate&lt;/em&gt; en renverra le nombre.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-b&lt;/strong&gt; ou &lt;strong&gt;--basename&lt;/strong&gt; : Liste uniquement les fichiers dont le &lt;em&gt;nom&lt;/em&gt; contient le motif (et non plus le chemin).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-A&lt;/strong&gt; ou &lt;strong&gt;--all&lt;/strong&gt;  : Liste les chemins contenant &lt;em&gt;tous&lt;/em&gt; les motifs donnés (et non ceux en contenant au moins un).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Et par l&amp;rsquo;exemple, cela donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ locate zirka
/home/jul/Work/zirka.jpg
/home/jul/Desktop/zirka-listing.doc
/home/jul/Work/zirka/test1.data
/home/jul/Work/zirka/test2.data
[...]

$ locate -b zirka
/home/jul/Work/zirka.jpg
/home/jul/Desktop/zirka-listing.doc
[...]

$ locate zirka test
/home/jul/Work/zirka.jpg
/home/jul/Desktop/zirka-listing.doc
/home/jul/Work/zirka/test1.data
/home/jul/Work/zirka/test2.data
/home/jul/Work/tmp/test.txt
[...]

$ locate -A zirka test
/home/jul/Work/zirka/test1.data
/home/jul/Work/zirka/test2.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Par contre, pour des recherches plus précises et dans un dossier en particulier, on se tournera vers la commande &lt;strong&gt;find&lt;/strong&gt;. Elle prends en argument le chemin du dossier à partir duquel la recherche sera effectuée, et listera les fichiers présents dans le dossier et ses sous-dossiers. Il est aussi possible de lui spécifier des filtres avec les options, comme les quelques exemples suivants (plus de détails dans le manuel) :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-maxdepth &lt;em&gt;x&lt;/em&gt;&lt;/strong&gt; : Ne garde que les fichiers contenus dans une suite d&amp;rsquo;au plus &lt;em&gt;x&lt;/em&gt; dossiers (i.e. ayant une profondeur de &lt;em&gt;x&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-name &lt;em&gt;x&lt;/em&gt;&lt;/strong&gt; : Fichiers dont le nom est &lt;em&gt;x&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-type&lt;/strong&gt; : Filtre les fichiers par type

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-type d&lt;/strong&gt; pour les dossiers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-type f&lt;/strong&gt; pour les fichiers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-type l&lt;/strong&gt; pour les liens&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-ctime&lt;/strong&gt; : Filtre les fichiers par date de création. Il existe aussi les commandes similaires &lt;strong&gt;-mtime&lt;/strong&gt; et &lt;strong&gt;-atime&lt;/strong&gt;, qui filtrent respectivement par date de dernière modification ou de dernier accès.

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-ctime &lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; pour les fichiers créés il y a exactement &lt;em&gt;n&lt;/em&gt; jours.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-ctime &lt;em&gt;+n&lt;/em&gt;&lt;/strong&gt; pour les fichiers créés il y a plus de &lt;em&gt;n&lt;/em&gt; jours.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-ctime &lt;em&gt;-n&lt;/em&gt;&lt;/strong&gt; pour les fichiers créés il y a moins de &lt;em&gt;n&lt;/em&gt; jours.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-size&lt;/strong&gt; : Comme pour &lt;em&gt;-ctime&lt;/em&gt;, mais filtre par taille de fichiers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Et dans la pratique, cela donne:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pwd
/home/zirka/web-content

$ find .
.
./content
./content/test.txt
./content/post
./content/post/lfcs-navigate.md
./content/post/lfcs-commandline.md
./content/post/hello-world.md
./content/post/lfcs-search.md
./content/post/lfce-lfcs.md
./content/post/pourquoi-golang.md

$ find . -maxdepth 2
./content/test.txt

find . -type d
.
./content
./content/post

$ find . -mtime -1
./content
./content/post
./content/post/lfcs-commandline.md
./content/post/lfcs-search.md

find . -name test.txt
./content/test.txt

find . -name *golang.md
./content/post/pourquoi-golang.md
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Naviguer dans un système Linux</title>
      <link>https://zirkachok.github.io/2017/02/14/lfcs--naviguer-dans-un-syst%C3%A8me-linux</link>
      <pubDate>Tue, 14 Feb 2017 16:14:27 +0100</pubDate>
      
      <guid>https://zirkachok.github.io/2017/02/14/lfcs--naviguer-dans-un-syst%C3%A8me-linux</guid>
      <description>

&lt;p&gt;Maintenant que l&amp;rsquo;utilisation de la ligne de commande n&amp;rsquo;a plus de secret pour nous, il est temps de découvrir l&amp;rsquo;arborescence d&amp;rsquo;un système Linux et apprendre comment s&amp;rsquo;y orienter et naviguer dedans.&lt;/p&gt;

&lt;!-- Avant toute chose, je recommande d&#39;utiliser une Sandbox (un espace de test dédié et isolé) pour réaliser les exercices et manipulations de cette série. Comme nous allons être amenés à réaliser des manipulations plus ou moins critiques et à altérer le fonctionnement du système, le faire depuis son environnement de tous les jours peut s&#39;avérer risqué si vous ne savez pas exactement ce que vous faites. --&gt;

&lt;div class=&#34;warning&#34;&gt;Il s&#39;agit ici d&#39;une introduction destinée aux débutants. Pour ceux d&#39;entre vous déjà familiers avec la ligne de commande, vous y apprendrez peut-être quelque chose, ou peut-être pas, mais dans tous les cas vous pouvez passer sans scrupules à un article plus avancé.&lt;/div&gt;

&lt;h1 id=&#34;l-arborescence&#34;&gt;L&amp;rsquo;arborescence&lt;/h1&gt;

&lt;p&gt;Linux repose sur une arborescence pour organiser les fichiers au sein du système&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Chaque fichier ou dossier se situe donc virtuellement dans une succession de répertoires, remontant jusqu&amp;rsquo;à la racine du système de fichiers (dénommée &amp;ldquo; / &amp;ldquo;): c&amp;rsquo;est ce qu&amp;rsquo;on appelle le &lt;strong&gt;chemin absolu&lt;/strong&gt;. Par simplicité, cette arborescence est souvent représentée comme un arbre inversé, avec la racine au sommet. Le dossier dans lequel vous vous trouvez est quand à lui appelé &lt;strong&gt;dossier courant&lt;/strong&gt; (ou &amp;ldquo;Working directory&amp;rdquo;), et il est aussi possible de représenter un chemin à partir de cet endroit: c&amp;rsquo;est alors un &lt;strong&gt;chemin relatif&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Dans cet exemple, le &lt;span style=&#34;color:blue&#34;&gt;chemin absolu vers le dossier &amp;ldquo;rainbow&amp;rdquo;&lt;/span&gt; est &amp;ldquo; &lt;em&gt;/home/zirka/somewhere/over/rainbow&lt;/em&gt; &amp;ldquo; . Comme le &lt;span style=&#34;color:magenta&#34;&gt;dossier courant&lt;/span&gt; est &amp;ldquo;zirka&amp;rdquo; (dont le chemin absolu est &amp;ldquo; &lt;em&gt;/home/zirka&lt;/em&gt; &amp;ldquo;), le &lt;span style=&#34;color:red&#34;&gt;chemin relatif vers le dossier &amp;ldquo;&lt;em&gt;rainbow&lt;/em&gt;&amp;ldquo;&lt;/span&gt; est &amp;ldquo; &lt;em&gt;somewhere/over/rainbow&lt;/em&gt; &amp;ldquo; .&lt;/p&gt;

&lt;h2 id=&#34;s-orienter-et-se-déplacer&#34;&gt;S&amp;rsquo;orienter et se déplacer&lt;/h2&gt;

&lt;p&gt;Dans la pratique, un certain nombre de commandes nous permettent de nous orienter et nous déplacer dans le système de fichier, en ligne de commande. Commençons par découvrir l&amp;rsquo;arborescence :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pwd&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Print Working Directory&lt;/em&gt;&amp;rdquo;) : retourne le chemin absolu du dossier courant&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ls&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;LiSt directory content&lt;/em&gt;&amp;rdquo;) : liste les fichiers &amp;amp; dossiers situés dans le dossier courant&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tree&lt;/strong&gt; : retourne une vue graphique de l&amp;rsquo;arborescence à partir du chemin courant&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pour toutes ces commandes, il est aussi possible de passer en argument un chemin donné, pour que l&amp;rsquo;opération soit effectuée à partir de ce dossier.&lt;/p&gt;

&lt;p&gt;Au passage, il est possible avec ls et bien d&amp;rsquo;autres commandes (find, file, etc.) de donner des &lt;strong&gt;motifs &amp;ldquo;abstraits&amp;rdquo;&lt;/strong&gt; plutôt qu&amp;rsquo;un nom précis. Sans entrer dans les détails, il est possible d&amp;rsquo;utiliser le caractère &lt;strong&gt;*&lt;/strong&gt; pour désigner &amp;ldquo;tout&amp;rdquo;. Par exemple, la commande &amp;ldquo; &lt;em&gt;ls *.bin&lt;/em&gt; &amp;ldquo; listera tous les fichiers dont le nom finit par &lt;em&gt;.bin&lt;/em&gt; .&lt;/p&gt;

&lt;p&gt;Enfin, c&amp;rsquo;est la commande &lt;strong&gt;cd&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Change Directory&lt;/em&gt;&amp;rdquo;) qui nous permet de nous déplacer. Si elle n&amp;rsquo;est pas complétée d&amp;rsquo;un argument, elle nous amènera directement au répertoire par défaut. Le plus souvent, il s&amp;rsquo;agit du répertoire personnel de l&amp;rsquo;utilisateur courant, dont le chemin par défaut est &amp;ldquo; &lt;em&gt;/home/username&lt;/em&gt; &amp;ldquo; avec &lt;em&gt;username&lt;/em&gt; l&amp;rsquo;identifiant de l&amp;rsquo;utilisateur. Il est aussi possible de donner à &lt;em&gt;cd&lt;/em&gt; un chemin absolu ou relatif au dossier courant pour s&amp;rsquo;y déplacer.&lt;/p&gt;

&lt;p&gt;À noter qu&amp;rsquo;il existe aussi certains raccourcis, comme :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;rdquo; &lt;em&gt;~&lt;/em&gt; &amp;ldquo; pour le répertoire personnel de l&amp;rsquo;utilisateur courant&lt;/li&gt;
&lt;li&gt;&amp;rdquo; &lt;em&gt;.&lt;/em&gt; &amp;ldquo; pour le répertoire courant&lt;/li&gt;
&lt;li&gt;&amp;rdquo; &lt;em&gt;..&lt;/em&gt; &amp;ldquo; pour le répertoire parent (celui qui contient le dossier courant)&lt;/li&gt;
&lt;li&gt;&amp;rdquo; &lt;em&gt;-&lt;/em&gt; &amp;ldquo; pour le répertoire précédent (celui où vous étiez avant le dernier déplacement)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cela nous donne donc via le terminal (les commandes que nous entrons sont ici précédées du symbole &amp;ldquo;$&amp;rdquo;) :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pwd
/home/zirka

$ tree 
.
├── config.xml
├── somewhere
│   └── over
│       └── rainbow
│           ├── high.c
│           ├── up.mk
│           └── way.c

$ ls
somewhere

$ ls somewhere/over/rainbow
high.c  up.mk  way.c

$ ls ~/somewhere/over/rainbow
high.c  up.mk  way.c

$ cd /home/zirka/somewhere/over/rainbow
$ ls
high.c  up.mk  way.c

$ ls *.c
high.c  way.c
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- &lt;span style=&#34;color:red&#34;&gt;!!! **Important !!!**&lt;/span&gt; Lorsque vous avez un doute sur l&#39;utilisation d&#39;une commande, la commande **man** suivie du nom de celle recherchée (e.g. *man pwd* ) vous affichera une page d&#39;aide, avec son utilisation, ses options, etc. --&gt;

&lt;h2 id=&#34;créer-et-détruire&#34;&gt;Créer et détruire&lt;/h2&gt;

&lt;p&gt;Nous avons vu comment naviguer dans l&amp;rsquo;arborescence, reste maintenant à créer, déplacer, éditer et détruire des fichiers. Commencons par la création et le déplacement. Cela se passe avec les commandes suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mkdir&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Make Directory&lt;/em&gt;&amp;rdquo;) : permet de créer un répertoire avec pour chemin celui donné en argument&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;touch&lt;/strong&gt; : crée un fichier avec pour chemin celui donné en argument &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cp&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Copy&lt;/em&gt;&amp;rdquo;) : permet de copier un fichier d&amp;rsquo;un chemin vers un autre.

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;-r&lt;/em&gt; : avec l&amp;rsquo;option &amp;ldquo; &lt;em&gt;-r&lt;/em&gt; &amp;ldquo; (pour recursive), copie un dossier et tout son contenu.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mv&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Move&lt;/em&gt;&amp;rdquo;) : déplace un fichier d&amp;rsquo;un chemin vers un autre. À noter que mv peut aussi être utilisé pour renommer un fichier/dossier.

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;-r&lt;/em&gt; : avec l&amp;rsquo;option &amp;ldquo; &lt;em&gt;-r&lt;/em&gt; &amp;ldquo;, permet de déplacer un dossier et tout son contenu.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cela nous donne donc via le terminal :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
├── config.xml
├── somewhere
│   └── over
│       └── rainbow
│           ├── high.c
│           ├── up.mk
│           └── way.c

$ mkdir highway
$ mkdir highway/to
$ touch highway/to/hell.txt
$ cp highway/to/hell.txt somewhere/over/rainbow
$ mv somewhere/over/rainbow/up.mk highway/to/hell.txt

$ tree
.
├── config.xml
├── highway
│   └── to
│       ├── hell.txt
│       └── up.mk
├── somewhere
│   └── over
│       └── rainbow
│           ├── hell.txt
│           ├── high.c
│           └── way.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voyons maintenant comment détruire des fichiers ou dossiers. Pour cela rien de plus simple, avec les commandes suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;rm&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Remove&lt;/em&gt;&amp;rdquo;) : supprime définitivement un fichier via le chemin passé en argument.

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;-r&lt;/em&gt; : avec l&amp;rsquo;option &lt;em&gt;-r&lt;/em&gt;, efface un dossier et tout son contenu&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rmdir&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Remove Directory&lt;/em&gt;&amp;rdquo;) : efface définitivement un dossier via le chemin passé en argument.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En pratique, cela nous donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
├── config.xml
├── highway
│   └── to
│       ├── hell.txt
│       └── up.mk
├── somewhere
│   └── over
│       └── rainbow
│           ├── hell.txt
│           ├── high.c
│           └── way.c

$ rm highway/to/hell.txt
$ rm highway/to/up.mk
$ rmdir highway/to
$ rm -r somewhere/over
$ touch highway/to/hell.txt
$ cp highway/to/hell.txt somewhere/over/rainbow
$ mv somewhere/over/rainbow/up.mk highway/to/hell.txt

$ tree
.
├── config.xml
└── somewhere
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous arrivons maintenant à la fin de notre premier acticle d&amp;rsquo;une longue série dédiée aux certifications de la fondation Linux. Nous avons abordé une première partie des commandes essentielles à connaître pour utiliser le terminal, en passant en revue les moyens de se repérer, créer et détruire dans l&amp;rsquo;arborescence Linux. Le prochain article complètera ce thème en abordant la question des liens, de la manipulation de fichiers, du manuel, et bien plus encore.&lt;/p&gt;

&lt;!--     Command Line

x   1. The Shell
x   2. pwd (Print Working Directory)
x   3. cd (Change Directory)
x   4. ls (List Directories)
x   5. touch
    6. file
    7. cat
    8. less
    9. history
x   10. cp (Copy)
x   11. mv (Move)
x   12. mkdir (Make Directory)
x   13. rm (Remove)
    14. find
    15. help
    16. man
    17. whatis
    18. alias
    19. exit

 --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Cette arborescence suit elle même une norme (le &amp;ldquo;Filesystems Hierarchy Standard&amp;rdquo;, FHS), que nous passerons au crible dans un article dédié.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;En fait, &amp;ldquo; &lt;em&gt;touch&lt;/em&gt; &amp;ldquo; permet de changer les dates d&amp;rsquo;un fichier (création, modification, etc.). Mais si ce fichier n&amp;rsquo;existe pas, il va le créer. À ma connaissance, il n&amp;rsquo;existe pas de commande dédiée pour créer un fichier.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Dompter la ligne de commande</title>
      <link>https://zirkachok.github.io/2017/02/12/lfcs--dompter-la-ligne-de-commande</link>
      <pubDate>Sun, 12 Feb 2017 16:14:27 +0100</pubDate>
      
      <guid>https://zirkachok.github.io/2017/02/12/lfcs--dompter-la-ligne-de-commande</guid>
      <description>

&lt;!-- ê î ô --&gt;

&lt;p&gt;Pour bien débuter ma série d&amp;rsquo;articles concernant Linux, son fonctionnement et son administration, je vous propose de nous plonger dans la fameuse ligne de commande pour en découvrir l&amp;rsquo;intérêt et le fonctionnement. Et en bonus, je vous livrerai quelques conseils pour y être plus rapide et efficace!&lt;/p&gt;

&lt;!-- je vais passer en revue les commandes et rde bases nécessaires pour s&#39;orienter et naviguer au sein du système de fichiers. Je parle bien de &#34;commandes&#34;, car ici comme dans toute la suite, nous passerons par la ligne de commande. --&gt;

&lt;!-- Avant toute chose, je recommande d&#39;utiliser une Sandbox (un espace de test dédié et isolé) pour réaliser les exercices et manipulations de cette série. Comme nous allons être amenés à réaliser des manipulations plus ou moins critiques et à altérer le fonctionnement du système, le faire depuis son environnement de tous les jours peut s&#39;avérer risqué si vous ne savez pas exactement ce que vous faites. --&gt;

&lt;!-- Ceci étant dit, plongeons nous dans cette fameuse ligne de commande, et voyons commant nous repérer et naviguer dans un système Linux.  --&gt;

&lt;div class=&#34;warning&#34;&gt;Il s&#39;agit ici d&#39;une introduction destinée aux débutants. Pour ceux d&#39;entre vous déjà familiers avec la ligne de commande, vous y apprendrez peut-être quelque chose, ou peut-être pas, mais dans tous les cas vous pouvez passer sans scrupules à un article plus avancé.&lt;/div&gt;

&lt;h1 id=&#34;la-ligne-de-commande-c-est-quoi&#34;&gt;La ligne de commande, c&amp;rsquo;est quoi?&lt;/h1&gt;

&lt;p&gt;L&amp;rsquo;interpréteur de commandes (aussi appelé &amp;ldquo;ligne de commande&amp;rdquo;) permet d&amp;rsquo;accéder aux fonctions essentielles du système d&amp;rsquo;exploitation, par le biais de &lt;strong&gt;commandes&lt;/strong&gt; données en entrée (dans notre cas, tapées au clavier). Parmi ces fonctions, on retrouve par exemple la manipulation de fichiers, le déplacement dans l&amp;rsquo;arborescence, la lecture du manuel et de l&amp;rsquo;aide, et bien d&amp;rsquo;autres fonctionnalités.&lt;/p&gt;

&lt;h2 id=&#34;à-quoi-bon&#34;&gt;À quoi bon?&lt;/h2&gt;

&lt;p&gt;À première vue, l&amp;rsquo;intérêt de la ligne de commande n&amp;rsquo;est pas forcément évident, et les applications graphiques peuvent sembler tout aussi efficaces bien plus abordables&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Mais avec l&amp;rsquo;expérience, il est souvent bien plus rapide et efficace de gérer son système Linux de cette manière que graphiquement. La ligne de commande permet de réaliser dans les moindres détails &lt;strong&gt;toutes&lt;/strong&gt; les opérations permises par le système, alors que les outils graphiques ne peuvent réaliser que les opérations usuelles. Pour enfoncer le clou, dans le cas des serveurs entre autres il s&amp;rsquo;agit même d&amp;rsquo;un passage obligé (ils n&amp;rsquo;ont généralement pas de mode graphique). Alors pour un administrateur, un professionnel, ou un utilisateur averti et curieux, impossible d&amp;rsquo;y échapper, alors autant s&amp;rsquo;y mettre dès maintenant.&lt;/p&gt;

&lt;!-- ## sh, bash, zsh, ... --&gt;

&lt;p&gt;Il existe de nombreux interpréteurs, les plus courant étant le Bourne Shell (&lt;em&gt;sh&lt;/em&gt;), le Bourne-Again Shell (&lt;em&gt;bash&lt;/em&gt;), le Z shell (&lt;em&gt;zsh&lt;/em&gt;), etc. Chacun a ses particularités&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, mais inutiler pour le moment (sauf par curiosité) de les essayer tous. Utilisez le plus répendu actuellement (et par défaut sur de nombreuses distributions de Linux) : &lt;strong&gt;bash&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;gagner-en-efficacité&#34;&gt;Gagner en efficacité&lt;/h1&gt;

&lt;p&gt;Aussi pratique soit-elle, la ligne de commande demande de l&amp;rsquo;entraînement pour être &amp;ldquo;domptée&amp;rdquo;. Impossible de faire l&amp;rsquo;impasse sur la dactylographie et la mémorisation de toutes les commandes et leurs options (pas de panique, ça rentre tout seul avec la pratique), mais il existe aussi de nombreuses commandes et raccourcis pour nous faciliter le travail (et gagner en efficacité et rapidité).&lt;/p&gt;

&lt;h2 id=&#34;se-déplacer-dans-les-commandes&#34;&gt;Se déplacer dans les commandes&lt;/h2&gt;

&lt;p&gt;Il arrive souvent de devoir se déplacer dans une commande que l&amp;rsquo;on est en train de taper. Plutôt que d&amp;rsquo;effacer ou tout recommencer, quelques raccourcis bien pratique permettent de s&amp;rsquo;y déplacer en un clin d&amp;rsquo;oeil :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-a&lt;/strong&gt; et &lt;strong&gt;Ctrl-e&lt;/strong&gt; permettent respectivement de se rendre au début ou à la fin de la ligne courante.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt-b&lt;/strong&gt; et &lt;strong&gt;Alt-f&lt;/strong&gt; permettent de se déplacer vers la gauche ou la droite mot par mot. Il est aussi possible d&amp;rsquo;utiliser à la place &lt;strong&gt;Ctrl-&amp;larr;&lt;/strong&gt; et &lt;strong&gt;Ctrl-&amp;rarr;&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-c&lt;/strong&gt; permet d&amp;rsquo;effacer la ligne courante. &lt;strong&gt;Ctrl-l&lt;/strong&gt; ou la commande &lt;strong&gt;clear&lt;/strong&gt; permettent d&amp;rsquo;effacer complètement le terminal courant. Bien pratique pour y voir plus clair!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-Shift-c/x/v&lt;/strong&gt; remplacent les raccourcis habituels pour copier, couper et coller.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-u&lt;/strong&gt; efface tout ce qui se trouve à gauche du curseur, et &lt;strong&gt;Ctrl-y&lt;/strong&gt; le colle à nouveau à son emplacement courant.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- Ctrl+Alt+F1 entrer en mode ligne de commande seule (non-graphique) --&gt;

&lt;p&gt;Une autre fonctionnalité intéressante est l&amp;rsquo;auto-complétion. Lorsque l&amp;rsquo;on entre une commande, il est possible d&amp;rsquo;appuyer sur la touche &lt;strong&gt;Tab&lt;/strong&gt; pour que celle-ci soit automatiquement complétée. En appuyant deux fois sur &lt;em&gt;Tab&lt;/em&gt;, la liste des complétions possibles est retournée.&lt;/p&gt;

&lt;h2 id=&#34;parcourir-l-historique&#34;&gt;Parcourir l&amp;rsquo;historique&lt;/h2&gt;

&lt;p&gt;Sous Linux, les dernières commandes entrées sont mémorisées, et peuvent être parcourues à l&amp;rsquo;aide des flèches &lt;em&gt;haut&lt;/em&gt; et &lt;em&gt;bas&lt;/em&gt;. Il est aussi possible de parcourir l&amp;rsquo;historique, via la commande &lt;strong&gt;history&lt;/strong&gt;. Encore plus pratique, appuyer sur &lt;strong&gt;Ctrl-r&lt;/strong&gt; nous fait entrer dans un mode spécifique, qui parcours cet historique lorsque l&amp;rsquo;on tape une commande, et propose la dernière commande entrée similaire. Ce mode est particulièrement pratique lorsque l&amp;rsquo;on répète régulièrement les mêmes commandes.&lt;/p&gt;

&lt;h1 id=&#34;trouver-de-l-aide&#34;&gt;Trouver de l&amp;rsquo;aide&lt;/h1&gt;

&lt;p&gt;Il est juste impossible de mémoriser toutes les commandes, et il n&amp;rsquo;est pas rare que l&amp;rsquo;on ait besoin d&amp;rsquo;une aide pour en connaitre le fonctionnement et les options. Pour cela, il existe le manuel, accessible par la commande &lt;strong&gt;man&lt;/strong&gt; suivie de la commande cherchée. On entre alors dans une interface identique à celle de &lt;em&gt;less&lt;/em&gt;, avec une explication complète de la commande en question. N&amp;rsquo;hésitez pas à chercher la page de manuel des commandes que nous avons vu jusque là, pour vous familiariser avec cet outil.&lt;/p&gt;

&lt;p&gt;De manière générale, ayez le réflèxe de lire le manuel pour toute nouvelle commande. Vous pourrez constater certaines similitudes (fonctionnement, arguments, etc.), et elles deviendront vite plus facile à retenir.&lt;/p&gt;

&lt;p&gt;Essayez d&amp;rsquo;utiliser ces commandes et raccourcis lors de vos tests, exercices, ou simplement sans raison particulière et vous verrez, vous ne pourrez plus vous en passer. D&amp;rsquo;ailleurs, cela vaut aussi pour la ligne de commande elle-même, alors &lt;a href=&#34;https://fr.wikipedia.org/wiki/Jetzt_geht&#39;s_los&#34;&gt;Jetzt geht&amp;rsquo;s los&lt;/a&gt;!&lt;/p&gt;

&lt;!-- 
REFS :
    https://www.linux.com/learn/intro-to-linux/2017/4/fabulous-bash-navigation-shortcuts
 --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Et dans une certaine mesure le sont, quand on ne cherche à réaliser que des opérations courantes)
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Les différences majeures étant la conformité au standard &lt;a href=&#34;https://fr.wikipedia.org/wiki/POSIX&#34;&gt;POSIX&lt;/a&gt; et quelques fonctionnalités supplémentaires (e.g. le changement automatique de répertoire avec zsh). Je reviendrai sur ces différences dans un prochain article.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Linux a 25 ans, il est temps de se certifier!</title>
      <link>https://zirkachok.github.io/2017/01/20/linux-a-25-ans-il-est-temps-de-se-certifier</link>
      <pubDate>Fri, 20 Jan 2017 16:01:18 +0100</pubDate>
      
      <guid>https://zirkachok.github.io/2017/01/20/linux-a-25-ans-il-est-temps-de-se-certifier</guid>
      <description>

&lt;p&gt;Linux fête cette année ses 25 ans, autant d&amp;rsquo;années pendant lesquelles nous l&amp;rsquo;avons vu prendre du poids. Son influence s&amp;rsquo;est tout particulièrement faite remarquer dans les secteurs ayant subi d&amp;rsquo;importantes transformations, tels que l&amp;rsquo;embarqué, le Cloud ou les smartphones, où il est devenu un acteur essentiel. Même les architectures mainframe commencent à lorgner de son côté&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, tout un symbole.&lt;/p&gt;

&lt;p&gt;Avec cet essor, Linux a aussi beaucoup gagné en reconnaissance et en ouverture au public. Les livres et tutoriels à son sujet sont maintenant légion, et de nombreuses entreprises sont demandeuses de profils experts en développement ou administration de tels systèmes. Linux est donc devenu un incontournable pour la plupars des ingénieurs informatique, mais il reste malgré tout pour beaucoup assez méconnu.&lt;/p&gt;

&lt;h1 id=&#34;mettre-en-avant-son-expertise&#34;&gt;Mettre en avant son expertise&lt;/h1&gt;

&lt;p&gt;Utilisateur quotidien d&amp;rsquo;environnements Linux allant de sytèmes embarqués minimalistes et serveurs dans le cadre de mon travail, aux distributions graphiques &amp;ldquo;classiques&amp;rdquo; sur mon ordinateur personnel, j&amp;rsquo;ai depuis mes débuts été versé dans ce domaine. Pourtant, il m&amp;rsquo;a aussi souvent été difficile de mettre en avant cette expertise et me différencier. La faute au fait que souvent, il est nécessaire de convaincre ses interlocuteurs rapidement, sans engager une conversation technique de haute volée&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Et à ce niveau, seuls deux critères comptent : l&amp;rsquo;expérience et les diplômes/certifications.&lt;/p&gt;

&lt;p&gt;Depuis 2014, la Fondation Linux&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; a lancé un programme destiné à former des ingénieurs et administrateurs système sur le système Linux, ainsi que des certifications reconnues dans ce domaine, les LFCS &amp;amp; LFCE (Linux Foundation Certified Sysadmin &amp;amp; Engineer)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;. Ces certifications rejoignent ainsi celles proposées par Red-Hat, qui ont peinent à gagner en reconnaissance du fait de leur spécificité, et offrent une sorte d&amp;rsquo;équivalent à celles proposées par Microsoft pour son système Windows.&lt;/p&gt;

&lt;p&gt;D&amp;rsquo;un point de vue pratique, les examens de certification se font à distance, contrôlés par la fondation Linux. Une évaluation est donnée suivant un barème précis, en suivant un programme public, offrant un certain gage de qualité et de transparence. Cette évaluation permet d&amp;rsquo;ailleurs aussi de se faire une idée assez précise du niveau de la personne. Le &lt;a href=&#34;https://training.linuxfoundation.org/certification/lfce&#34;&gt;programme&lt;/a&gt; est complet, et couvre la majorité des situations auxquelles peuvent être confronté un ingénieur dans son travail avec Linux. Une bonne nouvelle en somme, qui pourra permettre de mettre en avant de manière claire et transparente ses compétences.&lt;/p&gt;

&lt;h1 id=&#34;construire-ses-compétences&#34;&gt;Construire ses compétences&lt;/h1&gt;

&lt;p&gt;Mais revenons-en à moi quelques instants. J&amp;rsquo;avais accueilli avec beaucoup d&amp;rsquo;enthousiasme la naissance de ces certifications, et après avoir attendu les premiers retours à leur sujet, j&amp;rsquo;ai décidé de m&amp;rsquo;y plonger cette année. Et pour ne pas faire les choses à moitié, je vais proposer dans ces colonnes chaque semaine un article-tutoriel sur un sujet particulier touchant à Linux. Cela aura pour avantage de m&amp;rsquo;inciter à faire des recherches à ce sujet et à les mettre en forme, une bonne résolution en plus formel en quelque sorte.&lt;/p&gt;

&lt;p&gt;Chaque article sera composé de trois parties. Tout d&amp;rsquo;abord, je parlerai du système lui-même, des choix qui l&amp;rsquo;ont guidé et des grandes figures qui l&amp;rsquo;ont influencé, pour ensuite présenter une ou plusieurs fonctionnalités, et enfin je vous proposerai quelques exercices pour approfondir ces nouvelles connaissances. Alors rendez-vous ces prochaines semaines pour en découvrir un peu plus sur ce formidable projet qu&amp;rsquo;est le système Linux.&lt;/p&gt;

&lt;!-- La fondation Linux propose même un grand choix de [formations](https://training.linuxfoundation.org/) en ligne sur des sujets aussi variés que l&#39;administration des systèmes ou les infrastructures Cloud. Enfin, la virtualisation et les services Cloud permettent de tester une distribution facilement et à moindre frais. Ainsi, toutes les conditions sont réunies pour apprendre Linux dans les meilleures conditions.

Les &#34;Infrastructure as a service&#34; ou IaaS, comme [Scaleway](http://scaleway.com/) par exemple.
--&gt;

&lt;!-- # Et les certifications dans tout ça?
Pour mettre en avant ses compétences, les certifications restent un instrument de choix. Cependant, autant Microsoft propose des certifications claires et reconnues pour ses systèmes Windows, Autant pour Linux les choses sont moins claires.

La fondation Linux a même lancé un programme destiné à former des ingénieurs et administrateurs système sur le système Linux, ainsi que des certifications reconnues dans ce domaine, les LFCS &amp; LFCE (Linux Foundation Certified Sysadmin &amp; Engineer).
 --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;En témoignent des initiatives comme l&amp;rsquo;&lt;a href=&#34;https://www.openmainframeproject.org/&#34;&gt;Open Mainframe&lt;/a&gt;, soutenue par IBM et Hitachi entre autres.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Surtout lorsque Linux n&amp;rsquo;est pas bien connu par l&amp;rsquo;interlocuteur en question. On retrouve la plupart du temps en face de soi des responsables n&amp;rsquo;ayant que peu pied dans le technique, ou des &amp;ldquo;experts&amp;rdquo; pas nécessairement à jour avec la technologie.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Un consortium à but non lucratif dédié à promouvoir, protéger et standardiser Linux.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Outre les deux citées ici, la Fondation Linux propose un catalogue assez vaste de &lt;a href=&#34;https://training.linuxfoundation.org/&#34;&gt;formations&lt;/a&gt; en ligne sur des sujets aussi variés que l&amp;rsquo;administration des systèmes ou les infrastructures Cloud.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Quelques impressions sur le Go</title>
      <link>https://zirkachok.github.io/2017/01/18/quelques-impressions-sur-le-go</link>
      <pubDate>Wed, 18 Jan 2017 17:20:17 +0100</pubDate>
      
      <guid>https://zirkachok.github.io/2017/01/18/quelques-impressions-sur-le-go</guid>
      <description>

&lt;p&gt;Il y a de cela des années, j&amp;rsquo;avais opté pour python comme language de prédilection pour mes développements débarqués. J&amp;rsquo;étais à l&amp;rsquo;époque tombé sous le charme de sa syntaxe minimaliste, de son efficacité (dans le traitement des chaines de caractères notamment) et de l&amp;rsquo;étendue de ses librairies. Autant d&amp;rsquo;avantages qui me permettaient de réaliser rapidement et efficacement des outils là où mes langages de script ne suffisaient plus. Cependant, au fil des années, de nouvelles problématiques m&amp;rsquo;ont amené à me détourner petit à petit de ce langage&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. J&amp;rsquo;ai donc commencé à chercher si ce n&amp;rsquo;est un successeur au moins un complément.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; fait partie de ces langages &amp;ldquo;à la mode&amp;rdquo; ces dernières années (avec &lt;a href=&#34;https://www.scala-lang.org/&#34;&gt;Scala&lt;/a&gt;, &lt;a href=&#34;https://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt;, &lt;a href=&#34;http://dlang.org/&#34;&gt;D&lt;/a&gt;, etc.), mais il se démarque par sa croissance&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; et ses origines&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Je me suis donc laissé tenter, et vous fait part de mes impressions après quelques semaines d&amp;rsquo;utilisation.&lt;/p&gt;

&lt;h1 id=&#34;une-philosophie-nouvelle&#34;&gt;Une philosophie nouvelle&lt;/h1&gt;

&lt;p&gt;Comme le jeu du même nom, Le langage Go a été conçu pour être simple à apprendre, mais profond dans ses possibilités. Celà se traduit par de nombreux aspects, assez novateurs dans le monde du développement.&lt;/p&gt;

&lt;h2 id=&#34;un-langage-rigide&#34;&gt;Un langage rigide&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Au premier regard, avec un typage fort et une syntaxe stricte, le Go semble assez rigide. Pas question ici de faire les choses à sa sauce. Les crochets suivent la déclaration des méthodes/fonctions/conditions/boucles sur la même ligne, il est interdit d&amp;rsquo;importer une bibliothèque sans l&amp;rsquo;appeler dans le code, toute variable a un type fixe, etc. Il existe même &lt;a href=&#34;https://blog.golang.org/go-fmt-your-code&#34;&gt;un outil&lt;/a&gt; fourni par défaut pour rendre conforme la syntaxe d&amp;rsquo;un code source en suivant les pratiques préconisées ou imposées.&lt;/p&gt;

&lt;p&gt;Un exemple de code en Go :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;flag&amp;quot;
)

func main() {
    var svar string
    wordPtr := flag.String(&amp;quot;file&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;a string&amp;quot;)

    flag.StringVar(&amp;amp;svar, &amp;quot;svar&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;a string var&amp;quot;)
    flag.Parse()

    if fileExists(*filePtr) {
        fmt.Println(&amp;quot;Valid file provided&amp;quot;)
    } else {
        fmt.Println(&amp;quot;File &amp;quot; + *filePtr + &amp;quot; not found&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cela peut sembler désagréable, surtout lorsque l&amp;rsquo;on est habitué à des langages plus permissifs (la plupart des langages en fait&amp;hellip;). Cependant, cette rigidité a pour avantage de forcer une uniformisation du code, et donc de faciliter grandement son inter-compréhension et son maintien. À ce niveau, le Go est particulièrement adapté aux projets de grande taille impliquant des développeurs d&amp;rsquo;expériences différentes (comme dans la communauté Open-Source, par exemple).&lt;/p&gt;

&lt;p&gt;Pour contrebalancer, La syntaxe du Go emprunte beaucoup au C/C++&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;, en y mêlant des éléments issus de langages plus récents. Elle se veut donc rassurante tout en étant moderne et puissante. Reste qu&amp;rsquo;une telle rigueur est un parti-pris qui ne plaira pas à tout le monde.&lt;/p&gt;

&lt;h2 id=&#34;et-flexible-à-la-fois&#34;&gt;&amp;hellip;Et flexible à la fois&lt;/h2&gt;

&lt;p&gt;Passée cette première impression, le Go fait preuve de nombreuses avantages. Comme citer ses qualités et inconvénients demanderait un article à lui seul (qui viendra peut-être, qui sait), je ne m&amp;rsquo;attarderai que sur ceux qui m&amp;rsquo;ont semblé les plus marquants :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Optimisé et optimisable&lt;/strong&gt; : Le langage Go, suivant le cas d&amp;rsquo;utilisation, n&amp;rsquo;est pas forcément le plus rapide ni le moins gourmand, comme le montrent les &lt;a href=&#34;https://days2011.scala-lang.org/sites/days2011/files/ws3-1-Hundt.pdf&#34;&gt;études&lt;/a&gt; sur le sujet. Par contre, outre la la présence d&amp;rsquo;un ramasse-miettes efficace, son utilisation du paradigme de programmation &lt;a href=&#34;https://blog.golang.org/concurrency-is-not-parallelism&#34;&gt;concurrente&lt;/a&gt; fait qu&amp;rsquo;il peut tirer le meilleur parti d&amp;rsquo;une architecture muti-coeurs sans perdre en qualité et propreté de code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Intuitif&lt;/strong&gt; : Comme je l&amp;rsquo;ai mentionné plus avant, pour qui est versé dans le C, C++ ou Java, le Go s&amp;rsquo;apprend de manière intuitive. Sa syntaxe proche de ces langages, la &lt;a href=&#34;https://blog.golang.org/error-handling-and-go&#34;&gt;gestion des erreurs&lt;/a&gt; simple et élégente, l&amp;rsquo;import des packages (notamment possible &lt;a href=&#34;https://golang.org/doc/code.html#ImportPaths&#34;&gt;via leur URL&lt;/a&gt;) largement simplifié, rendent sa prise en main rapide et facile. Comparé à aux langages fonctionnels tels que &lt;a href=&#34;https://www.scala-lang.org/&#34;&gt;Scala&lt;/a&gt; ou à des syntaxes plus originales comme &lt;a href=&#34;https://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt;, Go permet une transition rapide et efficace. Un atout de poids lorsque l&amp;rsquo;on travaille en équipe.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Des outils pour tout&lt;/strong&gt; : Go propose une large panoplie d&amp;rsquo;outils intégrés qui apportent un réel plus au langage en tant que tel. On y trouve entre autres &lt;a href=&#34;https://blog.golang.org/godoc-documenting-go-code&#34;&gt;Go doc&lt;/a&gt; pour la documentation automatique de code, &lt;a href=&#34;https://blog.golang.org/introducing-gofix&#34;&gt;Gofix&lt;/a&gt; pour la mise à niveau de code source au fil des versions, &lt;a href=&#34;https://golang.org/cmd/go/#hdr-List_packages&#34;&gt;Go list&lt;/a&gt; pour la génération des graphes de dépendances du package, &lt;a href=&#34;https://blog.golang.org/profiling-go-programs&#34;&gt;Go pprof&lt;/a&gt; pour le profilage, &lt;a href=&#34;https://blog.golang.org/debugging-go-code-status-report&#34;&gt;GDB&lt;/a&gt; pour le déboguage, et bien d&amp;rsquo;autres encore&amp;hellip; Enfin, il jouis d&amp;rsquo;une communauté très active proposant des packages variés et puissants&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, le tout en plus de ceux proposés officiellement.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Orienté Back-End&lt;/strong&gt; : La gestion native et optimisée protocoles et standards de l&amp;rsquo;Internet (&lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;HTTP&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/golang.org/x/crypto/ssh&#34;&gt;SSH&lt;/a&gt;, &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34;&gt;JSON&lt;/a&gt;, &lt;a href=&#34;https://golang.org/pkg/encoding/xml/&#34;&gt;XML&lt;/a&gt;, &lt;a href=&#34;https://golang.org/pkg/database/sql/&#34;&gt;SQL&lt;/a&gt;, &lt;a href=&#34;https://golang.org/pkg/crypto/&#34;&gt;cryptographie&lt;/a&gt;, etc.) et sa gestion de la concurrence font du Go un langage de choix pour le développement Cloud et Back-end. Ce n&amp;rsquo;est pas pour rien que des fournisseur de services comme SendGrid, Docker ou encore Dropbox s&amp;rsquo;y sont lancés.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Multi-plateformes&lt;/strong&gt; : Go intègre aussi nativement la &lt;a href=&#34;https://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5&#34;&gt;compilation croisée&lt;/a&gt;, permettant ainsi de compiler un executable pour une autre architecture que la sienne. Il offre la possibilité de réaliser des &lt;a href=&#34;https://blog.golang.org/c-go-cgo&#34;&gt;appels à du code C&lt;/a&gt;, et ainsi d&amp;rsquo;intégrer des bibliothèques héritées (ou Legacy code) plus facilement.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- Built with concurrency in mind --&gt;

&lt;h2 id=&#34;puissant-mais-perfectible&#34;&gt;Puissant, mais perfectible&lt;/h2&gt;

&lt;p&gt;Malgré tous ses apports, il reste au Go bien des défauts. Certains tiennent plus de choix clivants et d&amp;rsquo;une volonté de rester proche du C/C++, comme son typage fort et le manque d&amp;rsquo;&lt;a href=&#34;https://fr.wikipedia.org/wiki/Inf%C3%A9rence_de_types&#34;&gt;inférence de types&lt;/a&gt;, l&amp;rsquo;absence de paradigme orienté objet, ou encore l&amp;rsquo;usage de pointeurs que nous avons mentionnés plus haut, mais d&amp;rsquo;autres rentrent moins dans cette logique.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Pas de généricité&lt;/strong&gt; : Le défaut le plus évident est le manque de support pour la programmation générique et tout ce qu&amp;rsquo;elle apporte (dont le polymorphisme). Même si les &lt;a href=&#34;http://golangtutorials.blogspot.fr/2011/06/polymorphism-in-go.html&#34;&gt;interfaces&lt;/a&gt; peuvent remplir ce rôle et donc contourner le problème, on y perd grandement en transparence et en propreté du code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mutable ou immutable?&lt;/strong&gt; : Pour des &amp;ldquo;objets&amp;rdquo; complexes (structures, etc.), il n&amp;rsquo;est pas toujours évident de savoir si il sera copié ou modifié. Un objet peut etre passé par adresse et ainsi lever le doute, mais une gestion explicite de l&amp;rsquo;&lt;a href=&#34;https://fr.wikipedia.org/wiki/Objet_immuable&#34;&gt;immutabilité&lt;/a&gt; aurait été un plus bienvenu.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Pas le plus performant&lt;/strong&gt; : Comme mentionné plus haut, le langage Go n&amp;rsquo;est pas toujours le plus performant. Son empreinte mémoire est supérieure à celle de langages tels que C++ ou Scala, et il en va de même pour le temps d&amp;rsquo;exécution ou la taille du binaire généré. Malgré tout, Go reste un langage performant, tout est une question de priorités.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;au-final-ça-en-vaut-la-peine&#34;&gt;Au final, ça en vaut la peine?&lt;/h1&gt;

&lt;p&gt;Le Go peut en rebuter certains par ses choix clivants, mais ses inspirations font de lui un langage simple à apprendre mais profond, et qui apporte de nombreuses récompenses à qui fait l&amp;rsquo;effort de s&amp;rsquo;y investir. Il n&amp;rsquo;a certes pas les performances du C/C++ ou des langages fonctionnels modernes, mais il a pour lui la flexibilité du Python tout en étant plus maintenable et plus strict.&lt;/p&gt;

&lt;p&gt;En tout cas, il semble promis à un bel avenir, en témoigne &lt;a href=&#34;http://www.tiobe.com/tiobe-index/go/&#34;&gt;sa progression&lt;/a&gt;, sa communauté grandissante et son adoption par des grandes companies et services de l&amp;rsquo;Internet, tels que &lt;a href=&#34;http://fr.slideshare.net/jpetazzo/docker-and-go-why-did-we-decide-to-write-docker-in-go&#34;&gt;Docker&lt;/a&gt;, &lt;a href=&#34;https://blogs.dropbox.com/tech/2014/07/open-sourcing-our-go-libraries/&#34;&gt;Dropbox&lt;/a&gt;, &lt;a href=&#34;https://developers.soundcloud.com/blog/go-at-soundcloud&#34;&gt;Soundcloud&lt;/a&gt; ou encore &lt;a href=&#34;https://sendgrid.com/blog/convince-company-go-golang/&#34;&gt;SendGrid&lt;/a&gt;, &lt;a href=&#34;https://github.com/Netflix/rend&#34;&gt;Netflix&lt;/a&gt; et bien d&amp;rsquo;autres.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Pour n&amp;rsquo;en citer qu&amp;rsquo;une, rendre disponible et maintenir un outil pour des cibles n&amp;rsquo;ayant pas d&amp;rsquo;interpréteur python et/ou l&amp;rsquo;ensemble des librairies installées, est un parcours du combattant (pas de cross-compilation possible, nécessité d&amp;rsquo;utiliser des packets spécifiques, exécutables ainsi générés souvent lents et gourmands, etc.).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Le langage Go se situait en 2016 à la 13ème place au &lt;a href=&#34;http://www.tiobe.com/tiobe-index/&#34;&gt;classement Tiobe&lt;/a&gt; des langages les plus utilisés, contre la 54ème en 2015.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Le langage Go est issu des laboratoires de Google et de l&amp;rsquo;esprit de &lt;a href=&#34;https://en.wikipedia.org/wiki/Rob_Pike&#34;&gt;Rob Pike&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;La syntaxe elle-même, proche du style &lt;a href=&#34;https://fr.wikipedia.org/wiki/Style_d&#39;indentation#Style_K.26R&#34;&gt;K&amp;amp;R&lt;/a&gt;, l&amp;rsquo;usage des &lt;a href=&#34;https://blog.golang.org/gos-declaration-syntax&#34;&gt;pointeurs&lt;/a&gt;, etc.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;Pour une liste non exhaustive, on peut se référer &lt;a href=&#34;https://github.com/golang/go/wiki/Projects&#34;&gt;ici&lt;/a&gt;, &lt;a href=&#34;https://github.com/avelino/awesome-go&#34;&gt;là&lt;/a&gt; et &lt;a href=&#34;http://www.mjhall.org/golang-data-science-libraries/&#34;&gt;là-bas&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>