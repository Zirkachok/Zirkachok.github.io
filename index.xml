<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zirka</title>
    <link>https://zirkachok.github.io/index.xml</link>
    <description>Recent content on Zirka</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <copyright>Julien Beaudaux. Written in [Go](https://golang.org/), powered by [Hugo](//gohugo.io).</copyright>
    <lastBuildDate>Fri, 16 Jun 2017 14:59:06 +0200</lastBuildDate>
    <atom:link href="https://zirkachok.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LFCS : Tâches et gestion des ressources</title>
      <link>https://zirkachok.github.io/2017/06/16/lfcs--t%C3%A2ches-et-gestion-des-ressources</link>
      <pubDate>Fri, 16 Jun 2017 14:59:06 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/06/16/lfcs--t%C3%A2ches-et-gestion-des-ressources</guid>
      <description>

&lt;!-- â ê î ô û --&gt;

&lt;p&gt;Aujourd&amp;rsquo;hui, nous allons aborder la question des &lt;em&gt;tâches&lt;/em&gt; dans un environnement Linux, leur rôle et fonctionnement, ainsi que la manière dont il est possible de les gérer. De manière générale, plusieurs termes sont utilisés pour désigner une &lt;em&gt;tâche&lt;/em&gt; réalisée par le système d&amp;rsquo;exploitation. On parler parfois de &lt;em&gt;tâche&lt;/em&gt;, de &lt;em&gt;job&lt;/em&gt;, de &lt;em&gt;processus&lt;/em&gt;, ou encore de &lt;em&gt;thread&lt;/em&gt;, mais la différence entre ces désignations n&amp;rsquo;est pas toujours évidente. Essayons d&amp;rsquo;y voir plus clair, en les passant en revue une à une.&lt;/p&gt;

&lt;h1 id=&#34;quel-est-le-rôle-du-noyau-linux&#34;&gt;Quel est le rôle du noyau Linux ?&lt;/h1&gt;

&lt;p&gt;Commencons par expliquer comment fonctionne un système d&amp;rsquo;exploitation. Un &lt;strong&gt;système d&amp;rsquo;exploitation&lt;/strong&gt; (ou &lt;strong&gt;OS&lt;/strong&gt; pour &lt;em&gt;Operating System&lt;/em&gt;), le &lt;strong&gt;noyau Linux&lt;/strong&gt; dans notre cas, est un programme chargé de gérer l&amp;rsquo;utilisation des ressources (processeur/CPU, mémoire, RAM, etc.) d&amp;rsquo;un matériel informatique&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Il fournit également des services aux autres programmes pour s&amp;rsquo;interfacer avec le matériel&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; ou communiquer entre eux.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;OS partage les ressources disponibles entre les différentes tâches à exécuter, afin que différents codes puissent être exécutés en &amp;ldquo;simultané&amp;rdquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, c&amp;rsquo;est ce que l&amp;rsquo;on appelle l&amp;rsquo;&lt;strong&gt;ordonnancement de tâches&lt;/strong&gt; (ou &lt;em&gt;task scheduling&lt;/em&gt;). Ces tâches peuvent être de deux formes : les &lt;strong&gt;processus&lt;/strong&gt; (&lt;em&gt;process&lt;/em&gt; en anglais) et les &lt;strong&gt;threads&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;les-processus&#34;&gt;Les processus&lt;/h2&gt;

&lt;p&gt;Un &lt;strong&gt;processus&lt;/strong&gt; est un exécutable qui a accès à un partie de la mémoire qui lui est réservée. Cette mémoire contient les instructions à exécuter (le code) et les données utilisées par le programme pour fonctionner. Ces données sont elles-même divisées en deux sous-ensembles : la &lt;strong&gt;pile&lt;/strong&gt; (ou &lt;em&gt;stack&lt;/em&gt;) et le &lt;strong&gt;tas&lt;/strong&gt; (ou &lt;em&gt;heap&lt;/em&gt;). La &lt;strong&gt;pile&lt;/strong&gt; est la zone mémoire où sont stockées les variables locales et les adresses de retour des fonctions du code exécuté, alors que le &lt;strong&gt;tas&lt;/strong&gt; conserve en vrac tout le reste de la mémoire allouée par le programme.&lt;/p&gt;

&lt;p&gt;Le noyau conserve les adresses des différentes zones mémoire de chaque processus en cours d&amp;rsquo;exécution, ainsi que leurs fichiers ouverts, son identifiant unique, etc. Ces informations sont listées dans le répertoire &lt;strong&gt;/proc&lt;/strong&gt;, qui contient un sous-répertoire pour chaque processus (le processus &lt;em&gt;1&lt;/em&gt; étant celui lancé par le noyau Linux au démarrage). Le plan d&amp;rsquo;adressage (ou &lt;em&gt;mapping&lt;/em&gt;) est lui contenu dans le fichier &lt;strong&gt;maps&lt;/strong&gt; de chaque processus.&lt;/p&gt;

&lt;p&gt;Un processus a aussi une &lt;strong&gt;priorité&lt;/strong&gt; qui lui est propre. Plus le processus est prioritaire, plus l&amp;rsquo;OS lui fournira de ressource processeur (de cycle processeur) lors de l&amp;rsquo;ordonnancement des tâches.&lt;/p&gt;

&lt;h2 id=&#34;les-threads&#34;&gt;Les threads&lt;/h2&gt;

&lt;p&gt;Les processus sont relativement peu flexibles, car ils ont besoin qu&amp;rsquo;une partie de la mémoire leur soit dédiée en permanence et doivent passer par le système d&amp;rsquo;exploitation pour communiquer entre eux. C&amp;rsquo;est là que les &lt;strong&gt;threads&lt;/strong&gt; entrent en jeu. Un &lt;em&gt;thread&lt;/em&gt; est en quelque sorte un sous-ensemble de processus, il partage la même mémoire et les mêmes fichiers que le processus correspondant, mais exécute un code différent, là encore en simultané du processus et des autres &lt;em&gt;threads&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Pour le noyau Linux, un &lt;em&gt;thread&lt;/em&gt; partage donc les zones mémoire du processus auquel il est affilié, mais il s&amp;rsquo;agira d&amp;rsquo;une nouvelle entrée pour l&amp;rsquo;ordonnanceur de tâches.&lt;/p&gt;

&lt;p&gt;Souvent on emploie également les termes de &lt;strong&gt;tâches&lt;/strong&gt; et de &lt;strong&gt;job&lt;/strong&gt;. Une tâche désigne le plus souvent l&amp;rsquo;action réalisée par un processus ou un &lt;em&gt;thread&lt;/em&gt;, alors qu&amp;rsquo;un &lt;strong&gt;job&lt;/strong&gt; désigne en général l&amp;rsquo;action réalisée par un ou plusieurs processus (un navigateur Internet par exemple, qui utilise plusieurs processus, peut être vu comme un &lt;em&gt;job&lt;/em&gt;). Cependant, ces deux termes ne sont pas formellement définis (contrairement aux processus et &lt;em&gt;threads&lt;/em&gt;), et leur signification peut donc varier.&lt;/p&gt;

&lt;!-- Le problème d&#39;un processus c&#39;est que c&#39;est un peu lourd, cela implique des recopies de mémoire et surtout cela implique de passer par le système pour communiquer avec d&#39;autre processus. Il existe donc un autre concept nommé thread.

Un thread, c&#39;est un découpage d&#39;un processus. Cela veut dire qu&#39;il utilise exactement la même mémoire qu&#39;un processus, ainsi que les mêmes descripteurs de fichiers. Ce qui diffère d&#39;un thread à l&#39;autre ce sont uniquement les pointeurs d&#39;exécution et de pile. ce qui veut dire que 2 threads peuvent exécuter des bouts de code différents d&#39;un même exécutable et avoir des variables locales différentes de celles des autres threads du processus.

Du point de vue du noyau un thread est donc uniquement caractérisé par l&#39;état du processeur spécifiquement à l&#39;intérieur d&#39;un processus. Pour créer un nouveau thread, un thread existant (oeuf ou poule, un processus est déjà un thread) va appeler la fonction pthread_create() qui duplique la pile du thread existant et qui duplique l&#39;état du processeur. Le scheduler du noyau va donc voir une nouvelle entrée. --&gt;

&lt;h1 id=&#34;gérer-les-processus&#34;&gt;Gérer les processus&lt;/h1&gt;

&lt;h2 id=&#34;lister-les-processus&#34;&gt;Lister les processus&lt;/h2&gt;

&lt;p&gt;Sous linux, de nombreuses commandes permettent d&amp;rsquo;obtenir des informations sur les processus en cours d&amp;rsquo;exécution. Comme nous l&amp;rsquo;avons vu plus haut, chaque processus a un identifiant unique, et un dossier qui lui est propre dans le répertoire &lt;strong&gt;/proc&lt;/strong&gt;. Ce dossier contient en particulier les fichiers &lt;strong&gt;maps&lt;/strong&gt; et &lt;strong&gt;map_files&lt;/strong&gt;, contenant respectivement le plan d&amp;rsquo;adressage mémoire et les descripteurs de fichiers ouverts par le processus.&lt;/p&gt;

&lt;p&gt;Il est donc possible de lister les processus en cours d&amp;rsquo;exécution (ou &lt;em&gt;actifs&lt;/em&gt;) en listant les répertoires dans &lt;em&gt;/proc&lt;/em&gt;. Mais il existe aussi une commande pour cela : &lt;strong&gt;ps&lt;/strong&gt;. Par défaut &lt;em&gt;ps&lt;/em&gt; affiche les processus actifs sur le terminal courant, mais des options la rendent bien plus puissante :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-x&lt;/strong&gt; : retourne tous les processus actifs de l&amp;rsquo;utilisateur courant&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-ax&lt;/strong&gt; : retourne tous les processus actifs pour tous les utilisateurs&lt;/li&gt;
&lt;li&gt;** -p PID** : retourne le processus actif dont l&amp;rsquo;identifiant unique est &lt;em&gt;PID&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ps&lt;/em&gt; donne également pour chaque processus des informations basiques sur le processus. Avec l&amp;rsquo;option &lt;strong&gt;-u&lt;/strong&gt;, &lt;em&gt;ps&lt;/em&gt; fournit en plus des informations sur l&amp;rsquo;utilisateur possédant le processus, le pourcentage processeur/CPU et mémoire dédié, etc.&lt;/p&gt;

&lt;p&gt;Dans la pratique, cela nous donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ps -aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
...
zirka     3282  0.0  0.5 490924 21504 ?        Sl   08:27   0:01 /usr/lib/x86_64-linux-gnu/xfce4/panel-plugins/xfce4-xkb-plugin  8 6291499 xkb-plugin Dispositions du clavier Gre
zirka     3292  0.0  0.1 287132  4748 ?        Sl   08:27   0:00 /usr/lib/gvfs/gvfs-udisks2-volume-monitor
root      3295  0.0  0.2 367848  8516 ?        Ssl  08:27   0:00 /usr/lib/udisks2/udisksd --no-debug
zirka     3303  0.0  0.0 259036  2724 ?        Sl   08:27   0:00 /usr/lib/gvfs/gvfs-goa-volume-monitor
zirka     3308  0.0  0.1 405112  4900 ?        Sl   08:27   0:00 /usr/lib/gvfs/gvfs-afc-volume-monitor
...

$ sudo ls /proc
1   10   10220   11   ...   3282   3292   3295   3303   3308   ... 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;identifier-l-utilisation-des-ressources-par-processus&#34;&gt;Identifier l’utilisation des ressources par processus&lt;/h2&gt;

&lt;p&gt;Nous l&amp;rsquo;avons vu, la commande &lt;em&gt;ps&lt;/em&gt; peut indiquer le pourcentage CPU et mémoire dédié à chaque processus. Cependant, il existe des commandes bien plus efficaces et détaillées pour le faire : &lt;strong&gt;top&lt;/strong&gt; et sa variante interractive &lt;strong&gt;htop&lt;/strong&gt;. Ces commandes retournent l&amp;rsquo;ensemble des processus actifs avec leur utilisateur, priorité, utilisation CPU et mémoire et la commande associée, entre autres. &lt;em&gt;top&lt;/em&gt; et &lt;em&gt;htop&lt;/em&gt; affichent aussi les ressources totales disponibles. Chacune de ces commandes reste ouverte et rafraîchit les informations affichées en continu, jusqu&amp;rsquo;à ce que la touche &lt;em&gt;q&lt;/em&gt; soit pressée. De manière plus spécifique, la commande &lt;strong&gt;vmstat&lt;/strong&gt; permet aussi de monitorer l&amp;rsquo;utilisation de la mémoire virtuelle.&lt;/p&gt;

&lt;h2 id=&#34;changer-la-priorité-d-un-processus&#34;&gt;Changer la priorité d&amp;rsquo;un processus&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;ordonnanceur de tâches est chargé de gérer les processus, en leur allouant plus ou moins de cycles processeur/CPU en fonction de leur priorité (il s&amp;rsquo;agit du champs &lt;em&gt;time&lt;/em&gt; de la commande &lt;em&gt;top&lt;/em&gt;). Il est facile de faire l&amp;rsquo;analogie entre l&amp;rsquo;ordonnanceur et nous-même lorsque nous planifions nos activités. Parfois, il nous est possible de mener de front plusieurs tâches, et parfois une seule d&amp;rsquo;entre elle nécessite notre attention complète.&lt;/p&gt;

&lt;p&gt;Il est possible de donner des consignes au noyau Linux pour ordonnancer les processus le plus efficacement en fonction des besoins. Cela se fait via un paramètre appelé &lt;strong&gt;valeur nice&lt;/strong&gt; ou &lt;strong&gt;priorité&lt;/strong&gt; (voir le champ &lt;em&gt;PR&lt;/em&gt; de &lt;em&gt;top&lt;/em&gt;)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, allant de -20 à +19 et avec 0 la valeur par défaut. Plus un processus est prioritaire, plus sa &lt;em&gt;valeur nice&lt;/em&gt; sera faible, et plus il bénéficiera de ressources CPU lorsque nécessaire. En ajustant cette valeur, il est donc possible d&amp;rsquo;agir sur les ressources allouées à des processus particuliers (limiter la priorité d&amp;rsquo;un processus gourmand et non-essentiel, par exemple). Pour cela, il existe deux commandes : &lt;em&gt;nice&lt;/em&gt; et &lt;em&gt;renice&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La commande &lt;strong&gt;nice -n PRIO CMD&lt;/strong&gt; permet d&amp;rsquo;exécuter une commande &lt;em&gt;CMD&lt;/em&gt; avec une priorité &lt;em&gt;PRIO&lt;/em&gt; donnée. De la même manière, la commande &lt;strong&gt;renice PRIO -p PID&lt;/strong&gt; permet de changer la priorité du processus &lt;em&gt;PID&lt;/em&gt; en lui attribuant la valeur &lt;em&gt;PRIO&lt;/em&gt;. Enfin, il est possible de changer la priorité par défaut des processus lancés par un utilisateur ou groupe spécifique, en modifiant le fichier &lt;strong&gt;/etc/security/limits.conf&lt;/strong&gt;, comme expliqué dans &lt;a href=&#34;https://zirkachok.github.io/2017/06/14/lfcs--limiter-les-ressources-syst%C3%A8me&#34;&gt;mon article sur les limitations de ressources&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;pour-aller-plus-loin&#34;&gt;Pour aller plus loin&amp;hellip;&lt;/h1&gt;

&lt;p&gt;Voici mes inspirations ayant mené à cet article. Vous y trouverez des ressources vous permettant d&amp;rsquo;aller plus loin sur le sujet.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linux-attitude.fr/post/processus-et-threads&#34;&gt;Un article très détaillé sur le fonctionnement des processus et threads&lt;/a&gt; (FR)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/3073948/job-task-and-process-whats-the-difference&#34;&gt;Une question/réponse relative aux processus, threads, jobs et tâches&lt;/a&gt; (EN)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.octetmalin.net/linux/tutoriels/ps-connaitre-afficher-processus-actifs-a-un-moment-donne-instant-en-ligne-de-commande.php&#34;&gt;Des informations détaillées sur la commande ps&lt;/a&gt; (FR)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nixtutor.com/linux/changing-priority-on-linux-processes/&#34;&gt;Un article sur le changement de priorité de processus&lt;/a&gt; (EN)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cyberciti.biz/tips/linux-resource-utilization-to-detect-system-bottlenecks.html&#34;&gt;Un article complet sur vmstat&lt;/a&gt; (EN)&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 
https://unix.stackexchange.com/questions/4999/how-to-find-which-processes-are-taking-all-the-memory
https://www.cyberciti.biz/tips/linux-resource-utilization-to-detect-system-bottlenecks.html
 --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;En général il s&amp;rsquo;agit d&amp;rsquo;un ordinateur, mais en &lt;em&gt;informatique embarquée&lt;/em&gt; il peut s&amp;rsquo;agir d&amp;rsquo;une carte électronique seule, par exemple.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Typiquement, ces services permettent de s&amp;rsquo;attribuer des ressources. On y trouve par exemple des fonctions de création de &lt;em&gt;threads&lt;/em&gt; et &lt;em&gt;processus&lt;/em&gt;, d&amp;rsquo;allocation mémoire, d&amp;rsquo;entrée/sortie (I/O pour Input/Output) etc.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;En fait, les programmes sont exécutés chacun à leur tour, mais le passage d&amp;rsquo;une tâche à l&amp;rsquo;autre est tellement rapide et fréquent que cela donne l&amp;rsquo;impression qu&amp;rsquo;ils le sont en simultané. Lorsque des tâches sont exécutées sur deux matériels différents (et ne partagent donc pas les ressources processeur), on parle de &lt;strong&gt;parallélisme&lt;/strong&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;En somme, les pointeurs d&amp;rsquo;exécution et de pile sont différents pour chaque thread et leur processus.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;La &lt;em&gt;valeur nice&lt;/em&gt; et la &lt;em&gt;priorité&lt;/em&gt; d&amp;rsquo;un processus sont liés mais ne désignent pas exactement la même chose. Cependant ici nous considèrerons que si, par volonté de simplification.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Programmer des tâches</title>
      <link>https://zirkachok.github.io/2017/06/15/lfcs--programmer-des-t%C3%A2ches</link>
      <pubDate>Thu, 15 Jun 2017 08:50:34 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/06/15/lfcs--programmer-des-t%C3%A2ches</guid>
      <description>

&lt;!-- â ê î ô û --&gt;

&lt;!-- é è ù à --&gt;

&lt;p&gt;Lorsque l&amp;rsquo;on administre un système Linux, il est souvent nécessaire d&amp;rsquo;effectuer certaines tâches régulièrement. Pour n&amp;rsquo;en citer que quelques unes, il peut s&amp;rsquo;agir d&amp;rsquo;un backup régulier du système (voir en complément &lt;a href=&#34;https://zirkachok.github.io/2017/06/06/lfcs--archivage-et-compression&#34;&gt;mon article sur l&amp;rsquo;archivage&lt;/a&gt;), de maintenance (recherche de mises-à-jour), etc. Bien sûr, il est bien plus pratique d&amp;rsquo;automatiser ces tâches plutôt que de les effectuer manuellement. Sous Linux, il est facile de le faire, en programmant des tâches spécifiques pour s&amp;rsquo;exécuter à une date/heure donnée, et la commande qui va nous le permettre est &lt;strong&gt;cron&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;programmer-une-tâche-avec-cron&#34;&gt;Programmer une tâche avec &lt;em&gt;cron&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;cron&lt;/strong&gt; est un &lt;strong&gt;démon&lt;/strong&gt; (ou &lt;em&gt;daemon&lt;/em&gt;), c&amp;rsquo;est à dire une tâche exécutée en arrière plan (ou &lt;em&gt;background&lt;/em&gt;), qui va vérifier régulièrement la date/heure du système et lancer si nécessaire des tâches préprogrammées (appelées &lt;strong&gt;crontab&lt;/strong&gt;) contenues dans le fichier &lt;strong&gt;/etc/crontab&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Comme souvent, il est préférable de ne pas modifier ce fichier directement, mais plutôt d&amp;rsquo;utiliser la commande &lt;strong&gt;crontab -e&lt;/strong&gt;, qui le fera sans risque de mauvais formatage. Une tâche &lt;em&gt;cron&lt;/em&gt; se décrit donc en une ligne dans le fichier &lt;em&gt;/etc/crontab&lt;/em&gt;. Chaque ligne comprends 5 paramètres (chacun séparé par un espace ou une tabulation) : les minute, heure, jour du mois, mois et jour de la semaine (date/heure d&amp;rsquo;exécution de la tâche), ainsi que la commande à exécuter&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Dans la date/heure, un symbole &lt;strong&gt;*&lt;/strong&gt; permet de dire &amp;ldquo;tous&amp;rdquo; (tous les jours, tous les mois, etc.).&lt;/p&gt;

&lt;p&gt;La commande &lt;em&gt;crontab&lt;/em&gt; peut aussi prendre d&amp;rsquo;autres options, notamment :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-l&lt;/strong&gt; : Retourne la liste des tâches programmées&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-r&lt;/strong&gt; : Supprime la &lt;em&gt;crontab&lt;/em&gt; en cours&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-u&lt;/strong&gt; : Spécifie l&amp;rsquo;utilisateur dont les &lt;em&gt;crontab&lt;/em&gt; seront utilisées/modifiées&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-i&lt;/strong&gt; : Active une demande de confirmation avant de supprimer une &lt;em&gt;crontab&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Voyons par exemple comment programmer une tâche tous les 6 du mois à 6h25, et permettant d&amp;rsquo;archiver le répertoire &lt;em&gt;/home&lt;/em&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ crontab -l
no crontab for zirka

$ crontab -e
25 6 1 * * tar -cf /tmp/backup.tar /home

no crontab for zirka - using an empty one
crontab: installing new crontab

$ crontab -l
25 6 1 * * tar -cf /tmp/backup.tar /home

$ crontab -r
$ crontab -l
no crontab for zirka
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lors de la création d&amp;rsquo;une tâche &lt;em&gt;cron&lt;/em&gt;, il est aussi possible de remplacer les champs de date/heure par ces raccourcis :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;@reboot&lt;/strong&gt; : Effectue la tâche en question à chaque redémarrage du système&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@yearly&lt;/strong&gt; : Effectue la tâche en question tous les ans (équivalant à 0 0 1 1 *)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@monthly&lt;/strong&gt; : Effectue la tâche en question tous les mois (équivalant à 0 0 1 * *)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@daily&lt;/strong&gt; : Effectue la tâche en question tous les jours (équivalant à 0 0 * * *)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@hourly&lt;/strong&gt; : Effectue la tâche en question tous les mois (équivalant à 0 * * * *)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@weekly&lt;/strong&gt;, &lt;strong&gt;@midnight&lt;/strong&gt;, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;vérifier-la-complétion-de-tâches&#34;&gt;Vérifier la complétion de tâches&lt;/h1&gt;

&lt;p&gt;Lorsqu&amp;rsquo;une tâche est exécutée automatiquement, &lt;em&gt;cron&lt;/em&gt; écrit un ou plusieurs &lt;em&gt;logs&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; pour le signaler. Ces logs sont écrits par défaut dans le fichier &lt;strong&gt;/var/log&lt;/strong&gt; ou /var/log/syslog&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;. Par défaut, &lt;em&gt;cron&lt;/em&gt; n&amp;rsquo;enregistre que le début d&amp;rsquo;exécution des tâches (i.e. le fait qu&amp;rsquo;elles aient été lancées), mais il est possible d&amp;rsquo;indiquer à la commande &lt;em&gt;cron&lt;/em&gt; de logguer plus ou moins de choses. Pour cela, il suffit de l&amp;rsquo;appeler avec l&amp;rsquo;option &lt;strong&gt;-L&lt;/strong&gt; suivie d&amp;rsquo;une somme des valeurs suivantes (en fonctions des logs que nous voulons voir apparaitre) :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; : log le début d&amp;rsquo;exécution de toute tâche &lt;em&gt;cron&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2&lt;/strong&gt; : log la fin d&amp;rsquo;exécution de toute tâche &lt;em&gt;cron&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4&lt;/strong&gt; : log toute tâche &lt;em&gt;cron&lt;/em&gt; ayant échoué&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;8&lt;/strong&gt; : log l&amp;rsquo;identifiant du processus&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; de toute tâche &lt;em&gt;cron&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pour activer ces niveaux de logs, il suffit de modifier le fichier &lt;strong&gt;/etc/init/cron.conf&lt;/strong&gt;, qui régit l&amp;rsquo;initialisation de &lt;em&gt;cron&lt;/em&gt; lors du démarrage du système. Remplacez ainsi &lt;em&gt;exec cron&lt;/em&gt; par &lt;em&gt;exec cron -L 7&lt;/em&gt; par exemple.&lt;/p&gt;

&lt;p&gt;Pour nous faire une idée du fonctionnement des logs, programmons une tâche toutes les heures, qui ajoute une ligne à un fichier temporaire :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ crontab -l
no crontab for zirka

$ crontab -e
@hourly echo &amp;quot;Test en cours&amp;quot; &amp;gt;&amp;gt; /tmp/test.txt

$ crontab -l
@hourly echo &amp;quot;Test en cours&amp;quot; &amp;gt;&amp;gt; /tmp/test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Après quelques heures, regardons les logs :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /tmp/test.txt
Test en cours
Test en cours
Test en cours
Test en cours
Test en cours

$ cat /var/log/syslog | grep -i &amp;quot;cron&amp;quot;
Jun 16 08:58:51 Epinet crontab[22604]: (zirka) LIST (zirka)
Jun 16 08:49:54 Epinet crontab[21967]: (zirka) BEGIN EDIT (zirka)
Jun 16 08:50:10 Epinet crontab[21967]: (zirka) REPLACE (zirka)
Jun 16 08:50:10 Epinet crontab[21967]: (zirka) END EDIT (zirka)
Jun 16 08:58:51 Epinet crontab[22604]: (zirka) LIST (zirka)
Jun 16 09:00:01 Epinet CRON[22702]: (zirka) CMD (echo &amp;quot;Test en cours&amp;quot; &amp;gt;&amp;gt; /tmp/test.txt)
Jun 16 10:00:01 Epinet CRON[27080]: (zirka) CMD (echo &amp;quot;Test en cours&amp;quot; &amp;gt;&amp;gt; /tmp/test.txt)
Jun 16 11:00:01 Epinet CRON[31111]: (zirka) CMD (echo &amp;quot;Test en cours&amp;quot; &amp;gt;&amp;gt; /tmp/test.txt)
Jun 16 12:00:01 Epinet CRON[2688]: (zirka) CMD (echo &amp;quot;Test en cours&amp;quot; &amp;gt;&amp;gt; /tmp/test.txt)
Jun 16 13:00:01 Epinet CRON[7165]: (zirka) CMD (echo &amp;quot;Test en cours&amp;quot; &amp;gt;&amp;gt; /tmp/test.txt)

$ crontab -l
@hourly echo &amp;quot;Test en cours&amp;quot; &amp;gt;&amp;gt; /tmp/test.txt

$ crontab -r

$ crontab -l
no crontab for zirka
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;pour-aller-plus-loin&#34;&gt;Pour aller plus loin&amp;hellip;&lt;/h1&gt;

&lt;p&gt;Voici mes inspirations ayant mené à cet article. Vous y trouverez des ressources vous permettant d&amp;rsquo;aller plus loin sur le sujet.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.ubuntu-fr.org/cron&#34;&gt;Un article d&amp;rsquo;Ubuntu-fr sur le sujet&lt;/a&gt; (FR)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.thegeekstuff.com/2009/06/15-practical-crontab-examples/&#34;&gt;Une liste d&amp;rsquo;exemples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://bencane.com/2011/11/02/did-my-cronjob-run/&#34;&gt;Un article sur la vérification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Pour les systèmes basés sur &lt;em&gt;Debian&lt;/em&gt; (&lt;em&gt;Ubuntu&lt;/em&gt; par exemple), des sous-fichiers /etc/cron.daily, /etc/cron.weekly et /etc/cron.monthly sont gérés par le système, mais cela n&amp;rsquo;a pas d&amp;rsquo;impact majeur sur la manière de programmer des tâches.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Lors de l&amp;rsquo;écriture directe du fichier &lt;em&gt;/etc/crontab&lt;/em&gt;, un champs s&amp;rsquo;ajoute entre la date/heure et la commande : l&amp;rsquo;utilisateur. Avec la commande &lt;em&gt;crontab&lt;/em&gt;, l&amp;rsquo;utilisateur en cours sera choisi par défaut.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Un &lt;a href=&#34;https://en.wikipedia.org/wiki/Logfile&#34;&gt;&lt;em&gt;log&lt;/em&gt;&lt;/a&gt; est un événement enregistré par le système pour historisation.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Nous verrons plus en détail dans un prochain article comment analyser les logs système.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;Nous aborderons la question des processus et threads dans un prochain article.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Limiter les ressources système</title>
      <link>https://zirkachok.github.io/2017/06/14/lfcs--limiter-les-ressources-syst%C3%A8me</link>
      <pubDate>Wed, 14 Jun 2017 13:31:54 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/06/14/lfcs--limiter-les-ressources-syst%C3%A8me</guid>
      <description>

&lt;!-- â ê î ô û --&gt;

&lt;!-- é è ù à --&gt;

&lt;p&gt;Nous avons déjà vu comment limiter, pour chaque système de fichier, le volume de données et le nombre de fichiers qu&amp;rsquo;un utilisateur ou groupe a à sa disposition. Aujourd&amp;rsquo;hui, nous allons explorer un peu plus la question en limitant cette fois-ci les ressources système disponibles pour un utilisateur.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;utilisation de ces ressources, telles que la taille maximale des fichiers, le nombre maximal de fichiers ouverts, le nombre de processus, etc., sont autant de failles courantes dans les systèmes multi-utilisateurs. Imaginons un tel système sans limites : Tout utilisateur peut alors créer des processus à l&amp;rsquo;infini&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, ouvrir autant de fichiers que possible, etc., rendant de fait le système inutilisable. Il est donc essentiel par sécurité d&amp;rsquo;introduire des limites strictes à ce niveau, comme pour les quotas d&amp;rsquo;utilisation disque.&lt;/p&gt;

&lt;p&gt;Linux permet d&amp;rsquo;y parvenir facilement, via le fichier &lt;strong&gt;/etc/security/limits.conf&lt;/strong&gt;. Ce fichier est chargé à l&amp;rsquo;ouverture d&amp;rsquo;une session dans le système par &lt;em&gt;PAM&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, et définit l&amp;rsquo;ensemble des limites apposées pour un grand nombre de paramètres système, à chaque utilisateur. Pour changer ces paramètres, plutôt que d&amp;rsquo;écrire directement dans le fichier, nous utiliserons la commande &lt;strong&gt;ulimit&lt;/strong&gt; avec les options suivantes (entre autres) :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-a&lt;/strong&gt; : Affiche les limites pour chaque ressource système concernée&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-f&lt;/strong&gt; : Affiche (si seul) ou fixe (si suivi d&amp;rsquo;un nombre) la &lt;strong&gt;taille maximale d&amp;rsquo;un fichier&lt;/strong&gt; créé&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-n&lt;/strong&gt; : Affiche ou fixe le &lt;strong&gt;nombre maximum de fichiers ouverts&lt;/strong&gt; simultanément&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-t&lt;/strong&gt; : Affiche ou fixe le &lt;strong&gt;temps CPU maximal&lt;/strong&gt; pour un processus (i.e. son utilisation des ressources processeur)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-u&lt;/strong&gt; : Affiche ou fixe le &lt;strong&gt;nombre maximal de processus&lt;/strong&gt; simultanément&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-v&lt;/strong&gt; : Affiche ou fixe la &lt;strong&gt;quantité maximale de mémoire virtuelle&lt;/strong&gt; disponible pour un processus&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comme pour les quotas disque, &lt;em&gt;ulimit&lt;/em&gt; gère des limites strictes (&lt;strong&gt;hard limits&lt;/strong&gt;) avec l&amp;rsquo;option &lt;strong&gt;-H&lt;/strong&gt;, et non strictes (&lt;strong&gt;soft limits&lt;/strong&gt;) avec l&amp;rsquo;option &lt;strong&gt;-S&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Sans aucune de ces deux options, les deux types de limites sont motifiées simultanément.&lt;/p&gt;

&lt;p&gt;D&amp;rsquo;autres limites ne sont modifiables qu&amp;rsquo;en écrivant directement dans le fichier &lt;em&gt;/etc/security/limits.conf&lt;/em&gt;. On retrouve entre autres les champs :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;maxlogins : nombre maximal de connections en simultané à chaque utilisateur (le superutilisateur n&amp;rsquo;étant pas concerné)&lt;/li&gt;
&lt;li&gt;maxsyslogins : nombre maximal d&amp;rsquo;utilisateurs connectés en simultané au système&lt;/li&gt;
&lt;li&gt;nice : priorité maximale des processus de l’utilisateur&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Le fichier &lt;em&gt;/etc/security/limits.conf&lt;/em&gt; permet aussi une gestion fine des limites, en fonction des utilisateurs et groupes (faire varier les limites en fonction des utilisateurs, par exemple).&lt;/p&gt;

&lt;p&gt;Dans la pratique, cela nous donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ulimit -u
30353

$ ulimit -u 300

$ ulimit -u
300

$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) 1000000
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 772466
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) 1000000
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 30353
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pour-aller-plus-loin&#34;&gt;Pour aller plus loin&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Voici mes inspirations ayant mené à cet article. Vous y trouverez des ressources vous permettant d&amp;rsquo;aller plus loin sur le sujet.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L&amp;rsquo;&lt;a href=&#34;https://ss64.com/bash/ulimit.html&#34;&gt;entrée de manuel&lt;/a&gt; de &lt;em&gt;limits.conf&lt;/em&gt; (&lt;strong&gt;man limits.conf&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://access.redhat.com/solutions/61334&#34;&gt;Documentation Red Hat&lt;/a&gt; (EN)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.admin-linux.fr/controle-des-ressources-systemes-ulimit/&#34;&gt;Un excellent article sur la question&lt;/a&gt; (FR)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.linuxhowtos.org/Tips%20and%20Tricks/ulimit.htm&#34;&gt;Un résumé sur le sujet&lt;/a&gt; (EN)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tecmint.com/set-limits-on-user-processes-using-ulimit-in-linux/&#34;&gt;Un bel article de Tecmint&lt;/a&gt; (EN)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;C&amp;rsquo;est ce que l&amp;rsquo;on appelle une &lt;a href=&#34;https://www.admin-linux.fr/?p=7530&#34;&gt;fork bomb&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Nous aborderons &lt;strong&gt;PAM&lt;/strong&gt; (&lt;em&gt;Pluggable Authentication Modules&lt;/em&gt;) dans un prochain article.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;À noter que la limite stricte doit forcément être supérieure à la limite non-stricte.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Archivage et compression</title>
      <link>https://zirkachok.github.io/2017/06/06/lfcs--archivage-et-compression</link>
      <pubDate>Tue, 06 Jun 2017 11:06:04 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/06/06/lfcs--archivage-et-compression</guid>
      <description>

&lt;!-- â ê î ô û --&gt;

&lt;!-- é è ù à --&gt;

&lt;p&gt;Aucun système, qu&amp;rsquo;il soit pour un ordinateur personnel ou pour un réseau d&amp;rsquo;entreprise avec de nombreux noeuds et utilisateurs, n&amp;rsquo;est a l&amp;rsquo;abri d&amp;rsquo;une défaillance. Un disque dur peut tomber en panne, le système peut être compromis, un administrateur ou utilisateur peut faire une erreur, etc., et il est alors nécessaire de revenir en arrière, à un point de sauvegarde (&lt;strong&gt;snapshot&lt;/strong&gt;) sûr. Il est donc indispensable de mettre en place des sauvegardes régulières (&lt;strong&gt;backup&lt;/strong&gt;) de l&amp;rsquo;état du système, et d&amp;rsquo;être capable d&amp;rsquo;y basculer le cas échéant (&lt;strong&gt;restore&lt;/strong&gt;). Nous allons donc aujourd&amp;rsquo;hui voir comment archiver simplement et efficacement des données, et comment programmer des &lt;em&gt;backup&lt;/em&gt; réguliers de votre système.&lt;/p&gt;

&lt;p&gt;Les archives peut être vu comme des paquets contenant des fichiers et répertoires, et servent à conserver facilement des données dans un unique fichier. Par défaut, une archive resulte d&amp;rsquo;une simple concaténation des fichiers, avec quelques éventuelles informations sur la hiérarchie des fichiers, leurs droits, etc. Une archive peut cependant aussi être compressée, c&amp;rsquo;est-à-dire qu&amp;rsquo;un algorithme sera appliqué sur les fichiers pour les compresser (i.e. en réduire la taille). Nous allons voir ici les méthodes les plus courantes pour créer une archive, compressée ou non.&lt;/p&gt;

&lt;h1 id=&#34;archiver-avec-cpio&#34;&gt;Archiver avec &lt;em&gt;cpio&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;La commande &lt;strong&gt;cpio&lt;/strong&gt; (pour &lt;em&gt;copy in and out&lt;/em&gt;) date des débuts d&amp;rsquo;UNIX, et était prévue pour la sauvegarde de données sur des bandes magnétiques. Bien que d&amp;rsquo;autres commandes d&amp;rsquo;archivage aient vu le jour, &lt;em&gt;cpio&lt;/em&gt; reste présent dans la quasi-totalité des systèmes UNIX/Linux, notamment du fait de sa légèreté.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;cpio&lt;/em&gt; permet d&amp;rsquo;archiver, extraire et lister le contenu d&amp;rsquo;archives, avec les options suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;create&lt;/strong&gt; (ou -o) : Crée une archive&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;extract&lt;/strong&gt; (ou -i) : Extrait le contenu d&amp;rsquo;une archive&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;list&lt;/strong&gt; (ou -t) : Liste le contenu d&amp;rsquo;une archive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Le contenu à archiver peut être spécifié avec l&amp;rsquo;option &lt;strong&gt;-I&lt;/strong&gt; ou une redirection de la ligne de commande, et l&amp;rsquo;archive en sortie peut être spécifiée avec l&amp;rsquo;option &lt;strong&gt;-O&lt;/strong&gt; ou également une redirection. Par l&amp;rsquo;exemple, cela nous donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree 
.
├── config.xml
├── somewhere
│   └── over
│       └── rainbow
│           ├── high.c
│           ├── up.mk
│           └── way.c

$ find . -depth | cpio -o &amp;gt; test.cpio

$ ls
config.xml  somewhere   test.cpio

$ cat test.cpio | cpio -t
somewhere/over/rainbow/high.c
somewhere/over/rainbow/up.mk
somewhere/over/rainbow
somewhere/over
somewhere
config.xml
test.cpio
.
13 blocs
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;archiver-et-compresser-avec-tar&#34;&gt;Archiver et compresser avec &lt;em&gt;tar&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;La commande &lt;strong&gt;tar&lt;/strong&gt; permet aussi l&amp;rsquo;archivage, mais est plus récente et plus simple d&amp;rsquo;utilisation que &lt;em&gt;cpio&lt;/em&gt;. Elle gère par défaut des archives du même nom (aussi appelées tarballs), avec les options suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;create&lt;/strong&gt; ou &lt;strong&gt;-c&lt;/strong&gt; : Permet de créer une nouvelle archive à partir des fichiers donnés en paramètre.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;extract&lt;/strong&gt; ou &lt;strong&gt;-x&lt;/strong&gt; : Permet d&amp;rsquo;extraire le contenu d&amp;rsquo;une archive.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;list&lt;/strong&gt; ou &lt;strong&gt;-t&lt;/strong&gt; : Liste le contenu d&amp;rsquo;une archive.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;file ARCH&lt;/strong&gt; ou &lt;strong&gt;-f ARCH&lt;/strong&gt; : Désigne le fichier (archive, device, &amp;hellip;) à utiliser pour réaliser l&amp;rsquo;opération choisie.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cela nous donne par exemple :&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Archivage&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
├── config.xml
├── somewhere
│   └── over
│       └── rainbow
│           ├── high.c
│           ├── up.mk
│           └── way.c

$ tar -cf test.tar somewhere

$ tar -tf test.tar
somewhere/
somewhere/over/
somewhere/over/rainbow/
somewhere/over/rainbow/high.c
somewhere/over/rainbow/up.mk
somewhere/over/rainbow/way.c

$ rm -r somewhere

$ tree
.
├── config.xml
└── test.tar

$ tar -xf test.tar

$ tree
.
├── config.xml
├── somewhere
│   └── over
│       └── rainbow
│           ├── high.c
│           ├── up.mk
│           └── way.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;tar&lt;/em&gt; a aussi d&amp;rsquo;autres atouts dans sa manches, qui rendent son utilisation particulièrement intéressante pour les &lt;em&gt;backup&lt;/em&gt;. Il est par exemple possible :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;de n&amp;rsquo;ajouter que les fichiers plus récents qu&amp;rsquo;une certaine date avec l&amp;rsquo;option &lt;strong&gt;&amp;ndash;newer DATE&lt;/strong&gt; (ou &lt;strong&gt;-N DATE&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;de n&amp;rsquo;ajouter que les fichiers plus récents que ceux contenus dans l&amp;rsquo;archive avec l&amp;rsquo;option &lt;strong&gt;&amp;ndash;update&lt;/strong&gt; (ou &lt;strong&gt;-u&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;d&amp;rsquo;exclure les fichiers dont le nom suit un certain motif avec l&amp;rsquo;option &lt;strong&gt;&amp;ndash;exclude=MOTIF&lt;/strong&gt; ou &lt;strong&gt;-X=MOTIF&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;de compresser les données, par exemple avec l&amp;rsquo;option &lt;strong&gt;&amp;ndash;gzip&lt;/strong&gt; (ou &lt;strong&gt;-z&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;d&amp;rsquo;obtenir les différences entre le contenu de l&amp;rsquo;archive et le contenu sur le disque, avec l&amp;rsquo;option &lt;strong&gt;&amp;ndash;diff&lt;/strong&gt; (ou &lt;strong&gt;-d&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;archivage-et-backup&#34;&gt;Archivage et backup&lt;/h1&gt;

&lt;p&gt;J&amp;rsquo;ai effleuré la question en introduction, il est donc temps de rentrer dans le vif du sujet : l&amp;rsquo;archivage (ici, avec &lt;em&gt;tar&lt;/em&gt;) est largement utilisé pour effectuer du &lt;em&gt;backup&lt;/em&gt;. Il existe principalement 2 méthodes de backup : le &lt;strong&gt;backup complet&lt;/strong&gt;, où un archivage des données est réalisé régulièrement, le &lt;strong&gt;backup incrémental&lt;/strong&gt;, où seules les différences par rapport au dernier archivage sont conservées. Bien sûr, les &lt;em&gt;backup complets&lt;/em&gt; sont plus faciles à récupérer (pour un backup incrémental, on doit revenir à la dernière archive complète et appliquer un à un les archives incrémentales), mais les &lt;em&gt;backup incrémentaux&lt;/em&gt; sont évidemment plus légers, un juste équilibre des deux est donc souvent la meilleure approche.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;tar&lt;/em&gt; est parfaitement adapté aux &lt;em&gt;backup complets&lt;/em&gt; (avec notamment la compression), mais aussi aux &lt;em&gt;backup incrémentaux&lt;/em&gt; (avec les options &lt;em&gt;newer&lt;/em&gt;, &lt;em&gt;update&lt;/em&gt;, &lt;em&gt;diff&lt;/em&gt;, &amp;hellip;). Il comporte d&amp;rsquo;ailleurs une option spécifique pour ces derniers (utlisée pour l&amp;rsquo;archivage comme pour l&amp;rsquo;extraction) : &lt;strong&gt;&amp;ndash;listed-incremental=SNAP&lt;/strong&gt; (ou &lt;strong&gt;-g SNAP&lt;/strong&gt;), avec &lt;em&gt;SNAP&lt;/em&gt; un fichier de travail pour réaliser cette opération (le même doit être utilisé pour chaque prochain backup incrémental).&lt;/p&gt;

&lt;p&gt;Cela nous donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
├── somewhere
│   └── over
│       ├── 
│       └── rainbow bigfile.txt
│           ├── high.c
│           ├── up.mk
│           └── way.c

$ ls -al somewhere
total 204816
drwxrwxr-x 3 julien julien      4096 juin  13 11:54 .
drwxrwxr-x 3 julien julien      4096 juin  13 11:54 ..
-rw-rw-r-- 1 julien julien 209715200 juin  13 11:54 bigfile.txt
drwxrwxr-x 3 julien julien      4096 juin   7 11:09 over

$ tar --create --file=increm1.tar --listed-incremental=save.list somewhere/

$ ls -al increm1.tar
-rw-rw-r-- 1 julien julien 209725440 juin  13 11:56 increm1.tar

$ echo &amp;quot;Hello there&amp;quot; &amp;gt; somewhere/over/rainbow/way.c

$ tar --create --file=increm2.tar --listed-incremental=save.list somewhere/
-rw-rw-r-- 1 julien julien 10240 juin  13 11:58 increm2.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comme on peut le voir, la première itération de &lt;em&gt;tar&lt;/em&gt; pour notre backup incrémental crée une archive volumineuse, alors que la seconde est extrèmement légère, car peu de contenu a été changé entre temps.&lt;/p&gt;

&lt;p&gt;Nous avons vu un des premiers aspects du &lt;em&gt;backup&lt;/em&gt;, l&amp;rsquo;archivage et l&amp;rsquo;extraction. Reste qu&amp;rsquo;il est fastidieux (et dangereux&amp;hellip;) de faire ces opérations à la main, régulièrement. Nous verrons donc dans un prochain article comment automatiser ces tâches.&lt;/p&gt;

&lt;!-- tar is easier to use than cpio:

    When creating a tar archive, for each directory given as an argument, all files and subdirectories will be included in the archive.
    When restoring it reconstitutes directories as necessary.
    It even has a --newer option that lets you do incremental backups.
    The version of tar used in Linux can also handle backups that do not fit on one tape or whatever device you use.


Below are a few example of how to use tar for backups:



    Create an archive using -c or --create:

    $ tar --create --file /dev/st0 /root
    $ tar -cvf /dev/st0 /root

    You can specify a device or file with the -f or --file options.
     
    Create with multi volume option using -M or --multi-volume if your backup won&#39;t fit on one device:

    $ tar -cMf /dev/st0 /root

    You will be prompted to put next tape when needed.
     
    Verify files with compare option using -d or --compare:

    $ tar --compare --verbose --file /dev/st0
    $ tar -dvf /dev/st0

    After you make a backup, you can make sure that it is complete and correct using the above verification option. --&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Gérer les quotas disque</title>
      <link>https://zirkachok.github.io/2017/06/06/lfcs--g%C3%A9rer-les-quotas-disque</link>
      <pubDate>Tue, 06 Jun 2017 11:06:04 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/06/06/lfcs--g%C3%A9rer-les-quotas-disque</guid>
      <description>

&lt;!-- â ê î ô û --&gt;

&lt;!-- é è ù à --&gt;

&lt;p&gt;Dans un système où cohabitent plusieurs utilisateurs, un seul d&amp;rsquo;entre eux peut s&amp;rsquo;accaparer un grande partie des ressources. Cela se fait bien sûr au détriment des autres utilisateurs, mais peut aussi rendre le système indisponible. Pour éviter ces situations, il est possible d&amp;rsquo;instaurer des quotas et limites pour chaque utilisaterur sur le nombre de fichiers qu&amp;rsquo;il peut posséder, ou sur l&amp;rsquo;espace disque dont il dispose. Ces quotas sont gérés par le systèmes, et peuvent s&amp;rsquo;appliquer à des utilisateurs autant qu&amp;rsquo;à des groupes.&lt;/p&gt;

&lt;h1 id=&#34;préparer-le-terrain&#34;&gt;Préparer le terrain&lt;/h1&gt;

&lt;p&gt;La gestion des quotas est une option du noyau, qui est activée par défaut pour la plupart des distributions Linux&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. En plus de cette option, il sera nécessaire d&amp;rsquo;installer des outils pour gérer leur utilisation, qui peuvent être obtenus via le &lt;strong&gt;paquet quotas&lt;/strong&gt;. Ce paquet comporte des utilitaires, des fichiers de configurations, des scripts de démarrage, etc.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Il est ensuite nécessaire d&amp;rsquo;activer les quotas indépendamment pour chaque système de fichiers. Pour ce faire, nous allons devoir modifier les options des systèmes de fichiers dans le fichier &lt;em&gt;/etc/fstab/&lt;/em&gt;, et ajouter pour chacun d&amp;rsquo;entre eux l&amp;rsquo;option usrquota (pour activer les quotas utilisateurs) et/ou grpquota (pour activer les quotas sur les groupes).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/sdc5   /home   ext3    usrquota,grpquota   1   1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cette ligne active dans cet exemple pour la partition &lt;em&gt;/dev/sdc5&lt;/em&gt;, qui est dans ce cas le sysème de fichers monté dans &lt;em&gt;/home&lt;/em&gt;, la gestion des quotas utilisateurs et groupes&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Après avoir installé &lt;em&gt;quota&lt;/em&gt; et configuré les sysèmes de fichiers, il ne nous reste plus qu&amp;rsquo;à appliquer les changements, soit en redémarrant le système, soit en remontant les systèmes de fichiers concernés avec la commande &lt;strong&gt;mount -o remount /mount-point&lt;/strong&gt; (avec /mount-point le point de montage concerné**.&lt;/p&gt;

&lt;h1 id=&#34;mettre-en-place-les-quotas&#34;&gt;Mettre en place les quotas&lt;/h1&gt;

&lt;p&gt;À présent, &lt;em&gt;quota&lt;/em&gt; devrait être pleinement fonctionnel sur votre système, mais les quotas eux-même ne sont pas paramétrés. La commande &lt;strong&gt;edquota&lt;/strong&gt; permet alors de le faire. Elle permet d&amp;rsquo;éditer le fichier de configuration temporaire &lt;strong&gt;/etc/quotatab&lt;/strong&gt; qui contrôle les quotas pour l&amp;rsquo;utilisateur spécifié en paramètre (l&amp;rsquo;option &lt;strong&gt;-g&lt;/strong&gt; permet de faire de même pour les groupes), et les systèmes de fichiers ayant l&amp;rsquo;option activée. Cela nous donne par exemple :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ edquota zirka
Filesystem  blocks  soft        hard        inodes  soft    hard
/dev/sdc5   97104   1048576     1048576     1242    0       0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On retrouve ici le nombre de blocs mémoire&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; composant le système de fichiers, et le nombre fichiers (i.e. inodes) présents, suivis des limites strictes (&lt;strong&gt;Hard limits&lt;/strong&gt;) et non-strictes (&lt;strong&gt;Soft limits&lt;/strong&gt;) dans chacun des cas. Les limites strictes ne peuvent pas être dépassées par l&amp;rsquo;utilisateur, le noyau Linux empêchant explicitement. Les limites non-strictes peuvent par contre être dépassées, mais leur dépassement génèrera un avertissement. Une valeur de &lt;em&gt;0&lt;/em&gt; pour une limite désactive la gestion des quotas dans ce cas.&lt;/p&gt;

&lt;p&gt;Il est aussi possible de mettre en place une &lt;strong&gt;période de grâce&lt;/strong&gt;, via l&amp;rsquo;option &lt;strong&gt;-t&lt;/strong&gt;, valable pour un système de fichier donné. Si un utilisateur dépasse son quota &amp;ldquo;non-strict&amp;rdquo; pendant une période plus longue, cette limite sera alors considérée comme si elle était &amp;ldquo;stricte&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Enfin, il est possible de vérifier et mettre à jour les informations sur les quotas via la commande &lt;strong&gt;quotacheck&lt;/strong&gt;, et de résumer ces informations pour un système de fichiers donné (ou pour tous avec l&amp;rsquo;option &lt;strong&gt;-a&lt;/strong&gt;) via la commande repquota.&lt;/p&gt;

&lt;!-- https://wiki.archlinux.org/index.php/disk_quota --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Si tel n&amp;rsquo;est pas le cas, il vous sera nécessaire de recompiler votre noyau en activant cette option (option &lt;em&gt;CONFIG_QUOTA&lt;/em&gt; dans la catégorie &lt;em&gt;File systems&lt;/em&gt;).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Il existe aussi un &lt;a href=&#34;http://en.tldp.org/HOWTO/Quota.html&#34;&gt;tutoriel en ligne&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Il est aussi possible qu&amp;rsquo;il faille activer le service &lt;em&gt;quota&lt;/em&gt; au démarrage du système. Référez-vous à l&amp;rsquo;article associé pour découvrir comment.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;La taille des blocs mémoire variant selon le matériel.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : La documentation passée au crible</title>
      <link>https://zirkachok.github.io/2017/05/22/lfcs--la-documentation-pass%C3%A9e-au-crible</link>
      <pubDate>Mon, 22 May 2017 09:21:55 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/05/22/lfcs--la-documentation-pass%C3%A9e-au-crible</guid>
      <description>

&lt;!-- ê î ô û --&gt;

&lt;p&gt;Aussi expérimenté que vous soyez, il est simplement impossible de retenir toutes les commandes disponibles sous Unix/Linux, leur rôle, leur fonctionnement, leurs paramètres et leurs arguments. Heureusement, il existe une documentation simple d&amp;rsquo;accès en ligne de commande et très fournie : le manuel. Aujourd&amp;rsquo;hui, nous allons donc nous plonger dans ce sujet&lt;/p&gt;

&lt;h1 id=&#34;le-manuel-en-ligne-de-commande&#34;&gt;Le manuel en ligne de commande&lt;/h1&gt;

&lt;p&gt;La commande de référence pour consulter une entrée du manuel est &lt;strong&gt;man&lt;/strong&gt;, suivie de la commande pour laquelle vous avez besoin d&amp;rsquo;informations&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Une page s&amp;rsquo;ouvrira alors dans le terminal pour afficher toutes les informations essentielles sur cette commande&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; : son rôle, son fonctionnement, ses options et paramètres, &amp;hellip; (Pour une description en une seule ligne, utiliser la commande &lt;strong&gt;whatis&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;Info alternative à man, &amp;hellip;&lt;/p&gt;

&lt;p&gt;Il est aussi possible de chercher des commandes à partir d&amp;rsquo;un mot clé, avec la commande &lt;strong&gt;apropos&lt;/strong&gt;. Celle-ci retourne toutes les commandes (et leur description) pour lesquelles le mot-clé est présent dans leur nom ou descriptions. Par exemple, pour cherchées toutes les commandes liées à l&amp;rsquo;algorithme de compression bzip2 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apropos bzip
bzcmp (1)            - compare bzip2 compressed files
bzdiff (1)           - compare bzip2 compressed files
bzegrep (1)          - search possibly bzip2 compressed files for a regular expression
bzfgrep (1)          - search possibly bzip2 compressed files for a regular expression
bzgrep (1)           - search possibly bzip2 compressed files for a regular expression
bzip2 (1)            - a block-sorting file compressor, v1.0.6
bzip2recover (1)     - recovers data from damaged bzip2 files
bzless (1)           - file perusal filter for crt viewing of bzip2 compressed text
bzmore (1)           - file perusal filter for crt viewing of bzip2 compressed text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La commande &lt;em&gt;man&lt;/em&gt; n&amp;rsquo;est qu&amp;rsquo;un outil de visualisation des pages de manuel, qui ne contient pas lui-même toutes les descriptions disponibles (appelées &lt;em&gt;entrées&lt;/em&gt;). En fait, &lt;em&gt;man&lt;/em&gt; consulte une base de données d&amp;rsquo;indexation des pages de manuel, créée ou mise-à-jour avec la commande &lt;strong&gt;mandb&lt;/strong&gt;. Cette base de données est construite à partir des emplacements et options spécifiés dans le fichier &lt;strong&gt;/etc/manpath.config&lt;/strong&gt; (à consulter pour mieux comprendre le fonctionnement du manuel).&lt;/p&gt;

&lt;h1 id=&#34;créer-sa-propre-entrée-de-manuel&#34;&gt;Créer sa propre entrée de manuel&lt;/h1&gt;

&lt;p&gt;Il est bien sûr possible de créer de toute pièce une entrée de manuel (par exemple, pour une commande &amp;ldquo;&lt;em&gt;maison&lt;/em&gt;&amp;rdquo; que vous avez créée). Les entrées de manuel suivent un format spécique, permettant à un système de traitement de documents nommé &lt;strong&gt;troff&lt;/strong&gt; (ou plutôt à l&amp;rsquo;un de ses packages, &lt;em&gt;groff an.tmac&lt;/em&gt;) d&amp;rsquo;en déduire la mise-en-page du document. Ce format fonctionne par l&amp;rsquo;intermédiaire de &lt;em&gt;Macros&lt;/em&gt; définissant les sections, les en-tête et pieds de page, etc.&lt;/p&gt;

&lt;p&gt;Pour comprendre comment fonctionne le formatage d&amp;rsquo;une entrée de documentation, le mieux est encore d&amp;rsquo;en lire une. Succintement, voici quelques macros utilisées :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NAME&lt;/strong&gt; : Le nom de la commande ou fonction, suivi d&amp;rsquo;une description en une ligne de son fonctionnement&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SYNOPSIS&lt;/strong&gt; : Une description plus complète de son fonctionnement et des options disponibles&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EXAMPLES&lt;/strong&gt; : Quelques exemples de son utilisation générale&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BUGS&lt;/strong&gt; : Les bugs connus liés à cette commande&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEE ALSO&lt;/strong&gt;, &lt;strong&gt;AUTHOR&lt;/strong&gt;, &lt;strong&gt;COPYRIGHT&lt;/strong&gt;, &lt;strong&gt;DESCRIPTION&lt;/strong&gt;, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Une fois la documentation réalisée, il suffit de la placer dans un des emplacements définis dans &lt;em&gt;/etc/manpath.config&lt;/em&gt;, de recréer la base de données d&amp;rsquo;indexation avec la commande &lt;em&gt;mandb&lt;/em&gt;, et le tour est joué.&lt;/p&gt;

&lt;!-- https://www.cyberciti.biz/faq/linux-unix-creating-a-manpage/ --&gt;

&lt;h1 id=&#34;références-sur-internet&#34;&gt;Références sur Internet&lt;/h1&gt;

&lt;p&gt;Le manuel Linux est incroyablement bien fourni et vous aidra à trouver la réponse à une grande partie de vos questions. Mais pour toutes les autres, il reste à se tourner vers Internet. De manière générale, le &lt;a href=&#34;https://wiki.archlinux.org&#34;&gt;&lt;strong&gt;wiki d&amp;rsquo;Archlinux&lt;/strong&gt;&lt;/a&gt; est une mine d&amp;rsquo;or en matière d&amp;rsquo;information et de résolution de problèmes. Une excellente alternative est la &lt;a href=&#34;https://access.redhat.com/documentation&#34;&gt;&lt;strong&gt;documentation en ligne de Red Hat&lt;/strong&gt;&lt;/a&gt;, ou encore le &lt;a href=&#34;http://www.tldp.org/&#34;&gt;&lt;strong&gt;Projet de Documentation Linux (TLDP)&lt;/strong&gt;&lt;/a&gt;. Enfin, le forum &lt;a href=&#34;https://stackexchange.com/&#34;&gt;&lt;strong&gt;stackexchange&lt;/strong&gt;&lt;/a&gt;, et en particulier son groupe &lt;a href=&#34;https://serverfault.com/&#34;&gt;&lt;strong&gt;serverfault&lt;/strong&gt;&lt;/a&gt;, permet de résoudre une vaste majorité des problèmes rencontrés dans la vie de tous les jours avec Linux.&lt;/p&gt;

&lt;!-- https://www.youtube.com/watch?v=59jnWX_EzTY&amp;index=123&amp;list=WL --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Il existe une alternative à &lt;em&gt;man&lt;/em&gt;, &lt;strong&gt;info&lt;/strong&gt;, qui sert de principale outil de documentation pour les Systèmes basés sur &lt;a href=&#34;https://en.wikipedia.org/wiki/GNU&#34;&gt;GNU&lt;/a&gt;. Cependant, bien que mieux organisée (avec des hyperliens par exemple), &lt;em&gt;info&lt;/em&gt; est souvent moins bien fournie.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Si plusieurs entrées existent pour cette commande, il n&amp;rsquo;affichera que la première.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Index des prérequis LFCS-LFCE</title>
      <link>https://zirkachok.github.io/2017/04/18/index-des-pr%C3%A9requis-lfcs-lfce</link>
      <pubDate>Tue, 18 Apr 2017 11:05:07 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/04/18/index-des-pr%C3%A9requis-lfcs-lfce</guid>
      <description>

&lt;!-- â ê î ô û --&gt;

&lt;p&gt;Chose promise, chose due. Voici donc un index des compétences officiellement requises par la Fondation Linux pour les certifications &lt;a href=&#34;https://training.linuxfoundation.org/certification/lfcs&#34;&gt;LFCS&lt;/a&gt; et &lt;a href=&#34;https://training.linuxfoundation.org/certification/lfce&#34;&gt;LFCE&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;warning&#34;&gt;Cette page sera mise à jour au fur et à mesure de l&#39;écriture des articles de blog. Elle est donc vouée à être constamment en chantier (du moins jusqu&#39;à la fin du tutoriel LFCS-LFCE.&lt;/div&gt;

&lt;p&gt;Mais avant cela, voici ce qeu dit la Fondation Linux sur cette liste de compétences (en VF) :&lt;/p&gt;

&lt;p&gt;&lt;em&gt;La fondation Linux a travaillé de concert avec des experts de l&amp;rsquo;industrie et la communauté du noyau Linux pour identifier les principaux domaines et les compétences, connaissances et aptitudes essentielles pour chaque certification.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Vous trouverez ci-dessous un sous-ensemble de la liste complète des domaines et compétences couverts par l&amp;rsquo;examen du LFCS/LFCE. Ce sous-ensemble représente les sujets ayant le plus de chances d&amp;rsquo;apparaître en considérant les technologies employées, les questions et les contraintes de temps de l&amp;rsquo;examen.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;linux-foundation-certified-sysadmin-lfcs&#34;&gt;Linux Foundation Certified Sysadmin (LFCS)&lt;/h1&gt;

&lt;h2 id=&#34;commandes-essentielles-25&#34;&gt;Commandes essentielles (25%)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Se connecter en mode graphique et texte&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Effectuer des recherches sur des fichiers&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/04/10/lfcs--effectuer-des-recherches-dans-larborescence&#34;&gt;[ici]&lt;/a&gt; et &lt;a href=&#34;https://zirkachok.github.io/2017/04/18/lfcs--utilisateurs-et-droits-le-retour&#34;&gt;[là]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Évaluer et comparer les fonctionnalités et options des systèmes de fichiers de base&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Comparer, créer et éditer des fichiers texte&lt;/span&gt; : &lt;a href=&#34;No page found with path or logical name &#34;lfcs-manipfile.md&#34;.
&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Comparer des fichiers binaires&lt;/span&gt; : &lt;a href=&#34;No page found with path or logical name &#34;lfcs-manipfile.md&#34;.
&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Utiliser les redirections des flux d&amp;rsquo;entrée et de sortie (e.g. &amp;gt;, &amp;gt;&amp;gt;, |, 2&amp;gt;)&lt;/li&gt;
&lt;li&gt;Analyser du texte en utilisant les expressions régulières de base&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Archiver, sauvegarder, compresser et décompresser des fichiers&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/06/06/lfcs--archivage-et-compression&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Créer, supprimer, copier et déplacer des fichiers et répertoires&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/02/14/lfcs--naviguer-dans-un-syst%C3%A8me-linux&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Créer des liens physiques et symboliques&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/04/11/lfcs--syst%C3%A8me-de-fichiers-et-liens&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Lister, affecter et modifier les permissions standard de fichiers&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/04/13/lfcs--utilisateurs-et-droits-dans-un-syst%C3%A8me-linux&#34;&gt;[ici]&lt;/a&gt; et &lt;a href=&#34;https://zirkachok.github.io/2017/04/18/lfcs--utilisateurs-et-droits-le-retour&#34;&gt;[là]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Lire et utiliser la documentation système&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/05/22/lfcs--la-documentation-pass%C3%A9e-au-crible&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Gérer les accès au compte superutilisateur (root)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Avancement : &lt;span style=&#34;color:red&#34;&gt;16%&lt;/span&gt; / 25% (&lt;sup&gt;8&lt;/sup&gt;&amp;frasl;&lt;sub&gt;13&lt;/sub&gt;)&lt;/p&gt;

&lt;!-- 
Essential Commands - 25%

    Log into graphical and text mode consoles
x   Search for files
    Evaluate and compare the basic file system features and options
    Compare, create and edit text files
    Compare binary files
    Use input-output redirection (e.g. &gt;, &gt;&gt;, |, 2&gt;)
    Analyze text using basic regular expressions
x   Archive, backup, compress, unpack, and uncompress files
x   Create, delete, copy, and move files and directories
x   Create hard and soft links
x   List, set, and change standard file permissions
x   Read, and use system documentation
    Manage access to the root account
--&gt;

&lt;h2 id=&#34;fonctionnement-des-systèmes-20&#34;&gt;Fonctionnement des systèmes (20%)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Démarrer, redémarrer et éteindre le système en toute sécurité&lt;/li&gt;
&lt;li&gt;Démarrer les systèmes manuellement sous différents niveaux de fonctionnement (runlevels)&lt;/li&gt;
&lt;li&gt;Installer, configurer et dépanner le bootloader&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Changer la priorité d&amp;rsquo;un processus&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/06/16/lfcs--t%C3%A2ches-et-gestion-des-ressources&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Identifier l&amp;rsquo;utilisation des ressources par processus&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/06/16/lfcs--t%C3%A2ches-et-gestion-des-ressources&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Localiser et analyser les fichiers de logs système&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Programmer des tâches pour se lancer à une certaine date et heure&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/06/15/lfcs--programmer-des-t%C3%A2ches&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Vérifier la complétion de tâches planifiées&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/06/15/lfcs--programmer-des-t%C3%A2ches&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mettre à jour des logiciels pour maintenir les fonctionnalités et la sécurité&lt;/li&gt;
&lt;li&gt;Vérifier l&amp;rsquo;intégrité et disponibilité de ressources&lt;/li&gt;
&lt;li&gt;Vérifier l&amp;rsquo;intégrité et disponibilité des processus clé&lt;/li&gt;
&lt;li&gt;Changer le paramétrage du noyau, de manière persistante ou non&lt;/li&gt;
&lt;li&gt;Utiliser des scripts pour automatiser des tâches de maintenance&lt;/li&gt;
&lt;li&gt;Gérer les processus de démarrage et services&lt;/li&gt;
&lt;li&gt;Lister et identifier les fichiers et contextes de processus SELinux et AppArmor&lt;/li&gt;
&lt;li&gt;Configurer et modifier les politiques SELinux et AppArmor&lt;/li&gt;
&lt;li&gt;Installer les logiciels depuis les sources&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Avancement : &lt;span style=&#34;color:red&#34;&gt;5%&lt;/span&gt; / 20% (&lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;17&lt;/sub&gt;)&lt;/p&gt;

&lt;!--
Operation of Running Systems - 20%

    Boot, reboot, and shut down a system safely
    Boot systems into different runlevels manually
    Install, configure and troubleshoot the bootloader
    Change the priority of a process
    Identify resource utilization by process
    Locate and analyze system log files
x   Schedule tasks to run at a set date and time
x   Verify completion of scheduled jobs
    Update software to provide required functionality and security
    Verify the integrity and availability of resources
    Verify the integrity and availability of key processes
    Change kernel runtime parameters, persistent and non-persistent
    Use scripting to automate system maintenance tasks
    Manage the startup process and services
    List and identify SELinux/AppArmor file and process contexts
    Configure and modify SELinux/AppArmor policies
    Install software from source
--&gt;

&lt;h2 id=&#34;gestion-des-utilisateurs-et-des-groupes-15&#34;&gt;Gestion des utilisateurs et des groupes (15%)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Créer, supprimer et modifier les comptes d&amp;rsquo;utilateurs locaux&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/04/13/lfcs--utilisateurs-et-droits-dans-un-syst%C3%A8me-linux&#34;&gt;[ici]&lt;/a&gt; et &lt;a href=&#34;https://zirkachok.github.io/2017/04/18/lfcs--utilisateurs-et-droits-le-retour&#34;&gt;[là]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Créer, supprimer et modifier les groupes locaux et leur appartenance&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/04/13/lfcs--utilisateurs-et-droits-dans-un-syst%C3%A8me-linux&#34;&gt;[ici]&lt;/a&gt; et &lt;a href=&#34;https://zirkachok.github.io/2017/04/18/lfcs--utilisateurs-et-droits-le-retour&#34;&gt;[là]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Manage system-wide environment profiles&lt;/li&gt;
&lt;li&gt;Manage template user environment&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Configuer les limites de ressources des utilisateurs&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/06/14/lfcs--limiter-les-ressources-syst%C3%A8me&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Gérer les processus utilisateurs&lt;/li&gt;
&lt;li&gt;Configurer le système d&amp;rsquo;authentification PAM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Avancement : &lt;span style=&#34;color:red&#34;&gt;7%&lt;/span&gt; / 15% (&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;7&lt;/sub&gt;)&lt;/p&gt;

&lt;!--
User and Group Management - 15%

x   Create, delete, and modify local user accounts
x   Create, delete, and modify local groups and group memberships
    Manage system-wide environment profiles
    Manage template user environment
x   Configure user resource limits
    Manage user processes
    Configure PAM
--&gt;

&lt;h2 id=&#34;réseaux-15&#34;&gt;Réseaux (15%)&lt;/h2&gt;

&lt;!-- Networking - 15%

    Configure networking and hostname resolution statically or dynamically
    Configure network services to start automatically at boot
    Implement packet filtering
    Configure firewall settings
    Start, stop, and check the status of network services
    Statically route IP traffic
    Dynamically route IP traffic
    Synchronize time using other network peers --&gt;

&lt;h2 id=&#34;configuration-des-services-10&#34;&gt;Configuration des services (10%)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Configurer un serveur DNS basique&lt;/li&gt;
&lt;li&gt;Maintenir une zone DNS&lt;/li&gt;
&lt;li&gt;Configurer un serveur FTP&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
Service Configuration - 10%

    Configure a basic DNS server
    Maintain a DNS zone
    Configure an FTP server
    Configure anonymous-only download on FTP servers
    Provide/configure network shares via NFS
    Provide/configure network shares via CIFS
    Configure email aliases
    Configure SSH servers and clients
    Configure SSH-based remote access using public/private key pairs
    Restrict access to the HTTP proxy server
    Configure an IMAP and IMAPS service
    Query and modify the behavior of system services at various run levels
    Configure an HTTP server
    Configure HTTP server log files
    Restrict access to a web page
    Diagnose routine SELinux/AppArmor policy violations
    Configure database server
--&gt;

&lt;h2 id=&#34;virtualisation-5&#34;&gt;Virtualisation (5%)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Configurer un hyperviseur pour héberger des hôtes virtuels&lt;/li&gt;
&lt;li&gt;Accéder à une console de la machine virtuelle (VM)&lt;/li&gt;
&lt;li&gt;Configurer le système pour démarrer des VMs au démarrage&lt;/li&gt;
&lt;li&gt;Évaluer l&amp;rsquo;utilisation mémoire de VMs&lt;/li&gt;
&lt;li&gt;Redimentionner la RAM et l&amp;rsquo;espace de stockage de VMs&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
Virtualization - 5%

    Configure a hypervisor to host virtual guests
    Access a VM console
    Configure systems to launch virtual machines at boot
    Evaluate memory usage of virtual machines
    Resize RAM or storage of VMs
--&gt;

&lt;h2 id=&#34;gestion-des-espaces-de-stockage-10&#34;&gt;Gestion des espaces de stockage (10%)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lister, créer, supprimer et modifier les partitions de stockage&lt;/li&gt;
&lt;li&gt;Créer, modifier, et supprimer des volumes logiques&lt;/li&gt;
&lt;li&gt;Étendre des volumes logiques et systèmes de fichiers existants&lt;/li&gt;
&lt;li&gt;Créer et configurer des partitions cryptées&lt;/li&gt;
&lt;li&gt;Configurer le système pour monter des systèmes de fichiers au démarrage&lt;/li&gt;
&lt;li&gt;Configurer et gérer le &lt;a href=&#34;https://fr.wikipedia.org/wiki/M%C3%A9moire_virtuelle#Swapping&#34;&gt;Swap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ajouter de nouvelles partitions et volumes logiques&lt;/li&gt;
&lt;li&gt;Assembler des partitions comme des dispositifs RAID&lt;/li&gt;
&lt;li&gt;Configurer le système pour monter à la demande des systèmes de fichiers standard, encryptés ou réseau&lt;/li&gt;
&lt;li&gt;Créer et gérer les Access Control Lists (ACLs) de systèmes de fichiers&lt;/li&gt;
&lt;li&gt;Diagnostiquer et corriger les problèmes de permissions fichiers&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;Mettre en place des quotas disque sur les systèmes de fichiers pour les utilisateurs et groupes&lt;/span&gt; : &lt;a href=&#34;https://zirkachok.github.io/2017/06/06/lfcs--g%C3%A9rer-les-quotas-disque&#34;&gt;[ici]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Avancement : &lt;span style=&#34;color:red&#34;&gt;1%&lt;/span&gt; / 10% (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;)&lt;/p&gt;

&lt;!--
Storage Management - 10%

    List, create, delete, and modify storage partitions
    Create, modify and delete Logical Volumes
    Extend existing Logical Volumes and filesystems
    Create and configure encrypted partitions
    Configure systems to mount file systems at or during boot
    Configure and manage swap space
    Add new partitions, and logical volumes
    Assemble partitions as RAID devices
    Configure systems to mount standard, encrypted, and network file systems on demand
    Create and manage filesystem Access Control Lists (ACLs)
    Diagnose and correct file permission problems
x   Setup user and group disk quotas for filesystems 
--&gt;

&lt;h1 id=&#34;linux-foundation-certified-engineer-lfce&#34;&gt;Linux Foundation Certified Engineer (LFCE)&lt;/h1&gt;

&lt;h2 id=&#34;administration-réseaux&#34;&gt;Administration réseaux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Configurer les services réseau pour les démarrer automatiquement au démarrage&lt;/li&gt;
&lt;li&gt;Implémenter le filtrage de paquets&lt;/li&gt;
&lt;li&gt;Surveiller les performances réseau&lt;/li&gt;
&lt;li&gt;Générer et transmettre des rapports sur l&amp;rsquo;utilisation système, les interruptions et les requètes utilisateur&lt;/li&gt;
&lt;li&gt;Router le trafic IP statiquement et dynamiquement&lt;/li&gt;
&lt;li&gt;Dépanner les problèmes réseau&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 
Network administration
    Configure network services to start automatically at boot
    Implement packet filtering
    Monitor network performance
    Produce and deliver reports on system use, outages and user requests
    Route IP traffic statically and dynamically
    Troubleshoot network issues
--&gt;

&lt;h2 id=&#34;systèmes-de-fichiers&#34;&gt;Systèmes de fichiers&lt;/h2&gt;

&lt;!-- 
Network filesystems and file services
    Configure systems to mount standard, encrypted and network file systems on demand
    Create, mount and unmount standard Linux file systems
    Provide/configure network shares via NFS
    Transfer files securely via the network
    Update packages from the network, a repository or the local file system
--&gt;

&lt;h2 id=&#34;sécurité-réseau&#34;&gt;Sécurité réseau&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Configurer les fichiers de log Apache&lt;/li&gt;
&lt;li&gt;Configurer le pare-feu avec iptables&lt;/li&gt;
&lt;li&gt;Installer et configurer SSL avec Apache&lt;/li&gt;
&lt;li&gt;Configurer un accès distant basé sur SSH en utilisant une paire de clés publique/privée&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
Network security
    Configure Apache log files
    Configure the firewall with iptables
    Install and configure SSL with Apache
    Configuring SSH-based remote access using public/private key pairs
--&gt;

&lt;h2 id=&#34;accès-distant&#34;&gt;Accès distant&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Configurer le pare-feu avec iptables&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 
Remote access
    Configure the firewall with iptables   ====&gt;&gt;   https://www.linux.com/learn/intro-to-linux/2017/5/building-linux-firewalls-good-old-iptables-part-1
 --&gt;

&lt;h2 id=&#34;services-http&#34;&gt;Services HTTP&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Configurer un client HTTP pour utiliser automatiquement un serveur proxy&lt;/li&gt;
&lt;li&gt;Installer et configurer un serveur web Apache&lt;/li&gt;
&lt;li&gt;Installer et configurer un serveur procy Squid&lt;/li&gt;
&lt;li&gt;Mettre en place un hébergement virtuel&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 
HTTP services
    Configure an http client to automatically use a proxy server
    Install and configure an Apache web server
    Install and configure the Squid proxy server
    Restrict access to a web page with Apache
    Restrict access to the Squid proxy server
    Setting up name-based virtual web hosts
 --&gt;

&lt;h2 id=&#34;services-email&#34;&gt;Services Email&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Configurer les alias mail&lt;/li&gt;
&lt;li&gt;Installer et configurer IMAP et le service IMAPS&lt;/li&gt;
&lt;li&gt;Installer et configurer le service SMTP&lt;/li&gt;
&lt;li&gt;Restreindre les accès à un serveur SMTP&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 
Email services
    Configure email aliases
    Install and configure an IMAP and IMAPS service
    Install and configure an smtp service
    Restrict access to an smtp server
 --&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Utilisateurs et droits, le retour</title>
      <link>https://zirkachok.github.io/2017/04/18/lfcs--utilisateurs-et-droits-le-retour</link>
      <pubDate>Tue, 18 Apr 2017 10:44:28 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/04/18/lfcs--utilisateurs-et-droits-le-retour</guid>
      <description>

&lt;!-- ê î ô û --&gt;

&lt;p&gt;Je vous ai présenté &lt;a href=&#34;https://zirkachok.github.io/2017/04/13/lfcs--utilisateurs-et-droits-dans-un-syst%C3%A8me-linux&#34;&gt;la fois précédente&lt;/a&gt; comment gérer les permissions et les utilisateurs au sein de votre système, mais le sujet est bien trop vaste pour être plié en un seul post de blog. Je vais donc revenir à la charge aujourd&amp;rsquo;hui avec de nouvelles commandes et quelques conseils appréciables pour optimiser leur gestion.&lt;/p&gt;

&lt;h1 id=&#34;gestion-avancée-des-permissions&#34;&gt;Gestion avancée des permissions&lt;/h1&gt;

&lt;h2 id=&#34;changer-de-propriétaire&#34;&gt;Changer de propriétaire&lt;/h2&gt;

&lt;p&gt;En plus de pouvoir changer les permissions d&amp;rsquo;un fichier, il est aussi possible d&amp;rsquo;en modifier l&amp;rsquo;utilisateur et le groupe propriétaire, respectivement avec les commandes &lt;strong&gt;chown&lt;/strong&gt; et &lt;strong&gt;chgrp&lt;/strong&gt; (qui nécessitent les droits administrateur). Ces commandes prennent en premier paramètre l&amp;rsquo;utilisateur/le groupe, suivi du fichier concerné. Il est aussi possible de changer à la fois l&amp;rsquo;utilisateur et le groupe propriétaires du fichier avec &lt;em&gt;chown&lt;/em&gt;, en combinant les deux séparés par &amp;ldquo; &lt;em&gt;:&lt;/em&gt; &amp;ldquo;.&lt;/p&gt;

&lt;p&gt;Par l&amp;rsquo;exemple, cela nous donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
-rwxrwxr--   1   calvin   humains   921   avril 10 15:47   test.txt

$ sudo chown hobbes test.txt
$ ls -l
-rwxrwxr--   1   hobbes   humains   921   avril 10 15:47   test.txt

$ sudo chgrp tigres test.txt
$ ls -l
-rwxrwxr--   1   hobbes   tigres    921   avril 10 15:47   test.txt

$ sudo chown calvin:humains test.txt
$ ls -l
-rwxrwxr--   1   calvin   humains   921   avril 10 15:47   test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;modifier-les-droits-par-défaut&#34;&gt;Modifier les droits par défaut&lt;/h2&gt;

&lt;p&gt;Chaque fichier créé se voit attribuer à sa création un ensemble de permissions par défaut, mais il est possible de modifier ces droits via la commande &lt;strong&gt;umask&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;!-- Par défaut, les permissions d&#39;un nouveau fichier sont 022 ou 002 --&gt;

&lt;p&gt;&lt;em&gt;umask&lt;/em&gt; utilise la variante numérique de modification des droits (voir l&amp;rsquo;article précédent, avec 4 pour l&amp;rsquo;accès en lecture, 2 en écriture et 1 en exécution), mais part de permissions complètes (donc &lt;em&gt;777&lt;/em&gt;) et y retranche celles données en argument. Avec &lt;em&gt;umask 021&lt;/em&gt; par exemple, on obtiendra les droits rwxr-xrw- (777 - 021 = 756). Dans la plupart des distributions, &lt;em&gt;umask&lt;/em&gt; est mis à 022 par défaut (soit rwxr-xr-x ou 755).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ touch test.txt
-rwxrwxr--   1   calvin   humains   921   avril 10 15:47   test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;!--
When you run the umask command it will give that default set of permissions on any new file you make. However, if you want it to persist you&#39;ll have to modify your startup file (.profile), but we&#39;ll discuss that in a later lesson. --&gt;

&lt;h2 id=&#34;cas-spécifique-des-suid-et-sgid&#34;&gt;Cas spécifique des SUID et SGID&lt;/h2&gt;

&lt;p&gt;Dans de nombreux cas, des utilisateurs &amp;ldquo;lambda&amp;rdquo; ont besoin de droits &amp;ldquo;privilégiés&amp;rdquo; pour certaines actions, mais les accès au compte administrateur ne peuvent pas être donnés à tous. Pour ces cas particuliers, il existe une permission spéciale, le &lt;strong&gt;Set User ID (SUID)&lt;/strong&gt;, qui permet de lancer une commande en étant considéré comme le propriétaire du fichier.&lt;/p&gt;

&lt;p&gt;Prenons un exemple. Disons qu&amp;rsquo;un utilisateur souhaite changer son mot de passe. Pour cela, il utilisera la commande &lt;em&gt;passwd&lt;/em&gt;, qui elle même modifiera les fichiers système &lt;em&gt;/etc/passwd&lt;/em&gt;. Cependant, ce fichier est propriété de l&amp;rsquo;administrateur et n&amp;rsquo;es modifiable que par lui. Regardons maintenant les permissions de la commande &lt;em&gt;passwd&lt;/em&gt; (fichier exécutable situé dans &amp;ldquo; &lt;em&gt;/usr/bin/passwd&lt;/em&gt; &amp;ldquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l /usr/bin/passwd
-rwSr-xr-x 1 root root 54256 mars  29  2016 /usr/bin/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vous remarquerez le nouveau caractère &lt;strong&gt;s&lt;/strong&gt; : il s&amp;rsquo;agit du SUID. Quand cette permission est mise sur un fichier, n&amp;rsquo;importe quel utilisateur exécutant ce fichier sera considéré comme son propriétaire, dans notre exemple l&amp;rsquo;administrateur (&lt;em&gt;root&lt;/em&gt;). Sans ce droit spécial, il serait impossible à un utilisateur de changer son mot de passe sans passer par le compte administrateur.&lt;/p&gt;

&lt;p&gt;Ce champ peut être affecté de manière symbolique comme n&amp;rsquo;importe quel droit, ou en précédent la représentation numérique des permissions d&amp;rsquo;un &lt;em&gt;4&lt;/em&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
-rw-rw-r--  1 julien julien    0 avril 18 16:06 test.txt

$ sudo chmod u+s test.txt
-rwSrw-r--  1 julien julien    0 avril 18 16:06 test.txt

$ sudo chmod u-s test.txt
-rw-rw-r--  1 julien julien    0 avril 18 16:06 test.txt

$ sudo chmod 4755 test.txt 
-rwsr-xr-x  1 julien julien    0 avril 18 16:06 test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De la même manière, il est possible d&amp;rsquo;autoriser l&amp;rsquo;exécution d&amp;rsquo;une commande en étant considéré comme appartenant au groupe propriétaire du fichier, et cela par l&amp;rsquo;intermédiaire de la permission &lt;strong&gt;Set Group ID (SGID)&lt;/strong&gt;. Ce champ peut être affecté de manière symbolique comme n&amp;rsquo;importe quel droit, ou en précédent la représentation numérique des permissions d&amp;rsquo;un &lt;em&gt;2&lt;/em&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
-rw-rw-r--  1 julien julien    0 avril 18 16:06 test.txt

$ sudo chmod g+s test.txt
-rw-rwSr--  1 julien julien    0 avril 18 16:06 test.txt

$ sudo chmod g-s test.txt
-rw-rw-r--  1 julien julien    0 avril 18 16:06 test.txt

$ sudo chmod 2555 test.txt 
-r-xr-sr-x  1 julien julien    0 avril 18 16:06 test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 

7. Process Permissions

Let&#39;s segue into process permissions for a bit, remember how I told you that when you run the passwd command with the SUID permission bit enabled you will run the program as root? That is true, however does that mean since you are temporarily root you can modify other user&#39;s passwords? Nope fortunately not!

This is because of the many UIDs that Linux implements. There are three UIDS associated with every process:

When you launch a process, it runs with the same permissions as the user or group that ran it, this is known as an effective user ID. This UID is used to grant access rights to a process. So naturally if Bob ran the touch command, the process would run as him and any files he created would be under his ownership.

There is another UID, called the real user ID this is the ID of the user that launched the process. These are used to track down who the user who launched the process is.

One last UID is the saved user ID, this allows a process to switch between the effective UID and real UID, vice versa. This is useful because we don&#39;t want our process to run with elevated privileges all the time, it&#39;s just good practice to use special privileges at specific times.

Now let&#39;s piece these all together by looking at the passwd command once more.

When running the passwd command, your effective UID is your user ID, let&#39;s say its 500 for now. Oh but wait, remember the passwd command has the SUID permission enabled. So when you run it, your effective UID is now 0 (0 is the UID of root). Now this program can access files as root.

Let&#39;s say you get a little taste of power and you want to modify Sally&#39;s password, Sally has a UID of 600. Well you&#39;ll be out of luck, fortunately the process also has your real UID in this case 500. It knows that your UID is 500 and therefore you can&#39;t modify the password of UID of 600. (This of course is always bypassed if you are a superuser on a machine and can control and change everything).

Since you ran passwd, it will start the process off using your real UID, and it will save the UID of the owner of the file (effective UID), so you can switch between the two. No need to modify all files with root access if it&#39;s not required.

Most of the time the real UID and the effective UID are the same, but in such cases as the passwd command they will change.

 --&gt;

&lt;h2 id=&#34;le-sticky-bit&#34;&gt;Le &amp;ldquo;Sticky bit&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;Parlons maintenant d&amp;rsquo;une dernière permissions spéciale: le &amp;ldquo;sticky bit&amp;rdquo;. Il est possible de rendre un fichier destructible seulement par son propriétaire et l&amp;rsquo;administrateur, et ce quelles que soient les permissions sur ce fichier. Prenons l&amp;rsquo;exemple du répertoire &amp;ldquo; &lt;em&gt;/tmp&lt;/em&gt; &amp;ldquo; (l&amp;rsquo;option &lt;em&gt;-d&lt;/em&gt; de &lt;em&gt;ls&lt;/em&gt; permet de lister les répertoires, et non leur contenu):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -ld /tmp
drwxrwxrwt 13 root root 135168 avril 19 14:19 /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vous remarquerez que le dernier caractère des droits est à &lt;strong&gt;t&lt;/strong&gt;. C&amp;rsquo;est le fameur &amp;ldquo;&lt;strong&gt;sticky bit&lt;/strong&gt;&amp;rdquo;. Ce dossier ne peut donc être supprimé que par l&amp;rsquo;administrateur, tout en étant modifiable par tous.&lt;/p&gt;

&lt;p&gt;Comme pour les SUID et SGID, le &amp;ldquo;sticky bit&amp;rdquo; peut être affecté de manière symbolique avec &lt;strong&gt;t&lt;/strong&gt; ou de manière numérique en précédent les droits d&amp;rsquo;un &lt;strong&gt;1&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
-rwxr-xr-x  1 julien julien    0 avril 18 16:06 test.txt

$ sudo chmod 1755 test.txt
$ ls -l
-rwxr-xr-t  1 julien julien    0 avril 18 16:06 test.txt

$ sudo chmod -t test.txt
$ ls -l
-rwxr-xr-x  1 julien julien    0 avril 18 16:06 test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;recherches-par-utilisateurs-et-permissions&#34;&gt;Recherches par utilisateurs et permissions&lt;/h1&gt;

&lt;p&gt;Je vous ai montré dans &lt;a href=&#34;https://zirkachok.github.io/2017/04/10/lfcs--effectuer-des-recherches-dans-larborescence&#34;&gt;un précédent article&lt;/a&gt; comment lister et trouver les fichiers dans le système, en proposant quelques filtres possibles. En voici quelques autres permettent de filtrer en fonction des utilisateurs, groupes et permissions :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;find -user &lt;em&gt;u&lt;/em&gt;&lt;/strong&gt; : Liste les fichiers appartenant à l&amp;rsquo;utilisateur &lt;em&gt;u&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;find -group &lt;em&gt;g&lt;/em&gt;&lt;/strong&gt; : Liste les fichiers appartenant au groupe &lt;em&gt;g&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;find -perm&lt;/strong&gt; : Liste les fichiers selon leurs permissions:

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-perm &lt;em&gt;p&lt;/em&gt;&lt;/strong&gt; : ne liste que les fichiers dont les permissions sont exactement &lt;em&gt;p&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-perm &lt;em&gt;-p&lt;/em&gt;&lt;/strong&gt; : liste les fichiers dont les permissions sont au moins &lt;em&gt;p&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-perm &lt;em&gt;/p&lt;/em&gt;&lt;/strong&gt; : liste les fichiers dont au moins un des droits de &lt;em&gt;p&lt;/em&gt; est setté.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Et en pratique, cela nous donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
-rw-r--r--  1 root    root     0 avril 18 16:11 supertest.txt
-rw-r--rw-  1 calvin  humains  0 avril 18 16:07 testbis.txt
-rw-rw-r--  1 hobbes  tigres   0 avril 18 16:14 testTer.txt
-rw-rw-r--  1 hobbes  tigres   0 avril 18 16:06 test.txt

$ find . -user hobbes
./testTer.txt
./test.txt

$ find . -group humains
./testbis.txt

$ find . -perm 664
./testTer.txt
./test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;!--
Ref : https://linuxjourney.com/lesson/file-permissions
--&gt;

&lt;!-- sudo --&gt;

&lt;!-- uname -a --&gt;

&lt;!-- Linux Epinet 3.13.0-93-generic #140-Ubuntu SMP Mon Jul 18 21:21:05 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux --&gt;

&lt;!--   A      B         C                                D                          E      F      G      H      --&gt;

&lt;!-- A = kernel name ; B = network node hostname ; C = kernel release ; D = kernel version ; E = machine hardware name --&gt;

&lt;!-- F = processor type (non-portable) ; G = hardware platform (non-portable) ; H = operating system --&gt;

&lt;!-- shutdown --&gt;

&lt;!-- logout --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;À noter que la modification des droits par défaut n&amp;rsquo;est pas persistante (elle ne sera plus valable après redémarrage de l&amp;rsquo;appareil par exemple). Pour l&amp;rsquo;affecter de manière permanente, il faudra modifier le profil de démarrage (fichier &lt;em&gt;.profile&lt;/em&gt;), mais j&amp;rsquo;aborderai ce point dans un autre article.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Utilisateurs et droits dans un système Linux</title>
      <link>https://zirkachok.github.io/2017/04/13/lfcs--utilisateurs-et-droits-dans-un-syst%C3%A8me-linux</link>
      <pubDate>Thu, 13 Apr 2017 08:46:32 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/04/13/lfcs--utilisateurs-et-droits-dans-un-syst%C3%A8me-linux</guid>
      <description>

&lt;!-- ê î ô û --&gt;

&lt;p&gt;Je vous ai déjà parlé en détails des fichiers et leur organisation sous Linux (&amp;ldquo;Tout est fichier&amp;rdquo; après tout), et aujourd&amp;rsquo;hui, je vais en ajouter une couche en abordant le thème des droits et permissions. Comme tout système d&amp;rsquo;exploitation (sauf rares exceptions, comme certains mainframe), Linux est capable de gérer plusieurs utilisateurs, et chacun d&amp;rsquo;entre eux n&amp;rsquo;a le droit d&amp;rsquo;accéder qu&amp;rsquo;à certains fichiers. Vous ne voudriez pas que votre famille et vos collègues puissent consulter et modifier &lt;em&gt;vos&lt;/em&gt; fichiers, n&amp;rsquo;est-ce pas?&lt;/p&gt;

&lt;h1 id=&#34;utilisateurs-et-groupes&#34;&gt;Utilisateurs et groupes&lt;/h1&gt;

&lt;p&gt;Plusieurs utilisateurs&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; cohabitent donc dans le système, chacun ayant un identifiant unique (&lt;strong&gt;UID&lt;/strong&gt; pour User ID) utilisé par le système, un nom (&lt;strong&gt;username&lt;/strong&gt;) qui est une représentation plus lisible associée à l&amp;rsquo;UID, un &lt;strong&gt;mot de passe&lt;/strong&gt;, et un répertoire personnel dans l&amp;rsquo;arborescence, qui contient les données propres à l&amp;rsquo;utilisateur (et dont le chemin par défaut est le plus souvent &amp;ldquo;&lt;em&gt;/home/username&lt;/em&gt;&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Cependant, gérer les droits de chaque fichier indépendemment pour chaque utilisateur serait lourd et complexe. Sous Linux, une alternative a donc été trouvée via les groupes. Un groupe liste l&amp;rsquo;ensemble des utilisateurs qui lui appartiennent. Comme pour les utilisateurs, chaque groupe a un identifiant unique (le &lt;strong&gt;GID&lt;/strong&gt; ou Group ID), un nom, et des permissions propres. Chaque utilisateur faisant partie d&amp;rsquo;un groupe en partagera aussi les droits, en plus des siens. À noter qu&amp;rsquo;un utilisateur peut appartenir à plusieurs groupes, multipliant d&amp;rsquo;autant plus les possibilités de gestion.&lt;/p&gt;

&lt;h2 id=&#34;le-cas-particulier-de-l-administrateur&#34;&gt;Le cas particulier de l&amp;rsquo;administrateur&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;un des utilisateurs les plus importants est l&amp;rsquo;&lt;strong&gt;administrateur&lt;/strong&gt; (aussi appelé &lt;em&gt;superutilisateur&lt;/em&gt; ou &lt;strong&gt;root&lt;/strong&gt;, dont l&amp;rsquo;UID est 0). Grossièrement, l&amp;rsquo;administrateur a tous les droits, alors que ceux des utilisateurs lambda sont limités : il a plein accès a n&amp;rsquo;importe quel fichier, peut créer et détruire des utilisateurs, modifier leurs droits, etc.&lt;/p&gt;

&lt;p&gt;Vous l&amp;rsquo;aurez compris, effectuer des actions en tant qu&amp;rsquo;administrateur peut s&amp;rsquo;avérer dangereux (détruire des fichiers système par exemple), mais est aussi bien souvent nécessaire, car les actions possibles pour un utilisateur lambda sont assez limitées. Deux approches sont possibles pour &amp;ldquo;devenir&amp;rdquo; administrateur :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Via la commande &lt;strong&gt;sudo&lt;/strong&gt; (pour SuperUser DO), qui permet d&amp;rsquo;exécuter une autre commande donnée après elle comme administrateur.&lt;/li&gt;
&lt;li&gt;Via la commande &lt;strong&gt;su&lt;/strong&gt; (pour SuperUser), qui permet de changer l&amp;rsquo;utilisateur courant pour l&amp;rsquo;administrateur&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;À noter que la commande &lt;strong&gt;id&lt;/strong&gt; permet d&amp;rsquo;obtenir les informations (UID, GID, groupes auquel il appartient) de l&amp;rsquo;utilsateur courant (ou un autre donné en argument).&lt;/p&gt;

&lt;h2 id=&#34;gérer-les-utilisateurs-et-groupes&#34;&gt;Gérer les utilisateurs et groupes&lt;/h2&gt;

&lt;p&gt;En pratique, la création d&amp;rsquo;un nouvel utilisateur passe par la commande &lt;strong&gt;adduser&lt;/strong&gt; suivie du nom de l&amp;rsquo;utilisateur. Cela effectuera les actions configurées dans &amp;ldquo; &lt;em&gt;/etc/adduser.conf&lt;/em&gt; &amp;ldquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, notamment (en général):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;générer un mot de passe (demandé par la commande lors de son exécution)&lt;/li&gt;
&lt;li&gt;créer un répertoire personnel associé à l&amp;rsquo;utilisateur (/home/&lt;em&gt;user&lt;/em&gt; par défaut)&lt;/li&gt;
&lt;li&gt;créer un groupe portant le même nom que cet utilisateur&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;De manière similaire, la commande &lt;strong&gt;deluser&lt;/strong&gt; permettra de supprimer un utilisateur, et fera les actions listées dans &amp;ldquo; &lt;em&gt;/etc/deluser.conf&lt;/em&gt; &amp;ldquo;. La commande &lt;strong&gt;passwd&lt;/strong&gt; peut aussi s&amp;rsquo;avérer utile: elle permet de changer le mot de passe de l&amp;rsquo;utilisateur courant (ou un autre donné en argument).&lt;/p&gt;

&lt;p&gt;Les groupes fonctionnent de manière identique, du moins dans leur gestion. Les commandes &lt;strong&gt;groupadd&lt;/strong&gt;, &lt;strong&gt;groupdel&lt;/strong&gt; permettent ainsi respectivement de créer et supprimer un groupe. La commande &lt;strong&gt;groups&lt;/strong&gt; permet elle de lister les groupes existants.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls /home
zirka

$ id testusr
id: «testusr» : utilisateur inexistant

$ sudo adduser testusr
$ ls /home
zirka  testusr

$ id testusr
uid=1001(testusr) gid=1001(testusr) groupes=1001(testusr)

$ sudo deluser testusr

$ id testusr
id: «testusr» : utilisateur inexistant
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fichiers-systèmes&#34;&gt;Fichiers systèmes&lt;/h2&gt;

&lt;p&gt;La gestion des utilisateurs et groupes passe (encore) par des fichiers, qui sont automatiquement modifiés par les commandes que nous venont de voir. Il n&amp;rsquo;est pas recommandé de les modifier soi-même (comme pour tous les fichiers système), mais on peut en lire le contenu pour obtenir des informations :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;/etc/passwd&lt;/strong&gt; contient la liste des utilisateurs et leurs informations. Chaque ligne contient :

&lt;ul&gt;
&lt;li&gt;le nom d&amp;rsquo;utilisateur, suivi d&amp;rsquo;un &lt;em&gt;x&lt;/em&gt; indiquant si le compte est protégé par un mot de passe&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;UID et GID associés à l&amp;rsquo;utilisateur&lt;/li&gt;
&lt;li&gt;des commentaires sur l&amp;rsquo;utilisateur (nom et coordonnées)&lt;/li&gt;
&lt;li&gt;le répertoire personnel et l&amp;rsquo;interpréteur par défaut (voir &lt;a href=&#34;https://zirkachok.github.io/2017/02/12/lfcs--dompter-la-ligne-de-commande&#34;&gt;mon article sur le shell&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/etc/shadow&lt;/strong&gt; contient les mots de passe des utilisateurs, et ne sont pas disponibles en clair (le fichier n&amp;rsquo;est d&amp;rsquo;ailleurs lisible que par l&amp;rsquo;administrateur)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/etc/group&lt;/strong&gt; contient toutes les informations sur les groupes. Chaque ligne contient :

&lt;ul&gt;
&lt;li&gt;le nom du groupe, suivi d&amp;rsquo;un &lt;em&gt;x&lt;/em&gt; indiquant si le groupe est protégé par un mot de passe&lt;/li&gt;
&lt;li&gt;le GID et les membres du groupe&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;les-permissions&#34;&gt;Les permissions&lt;/h1&gt;

&lt;p&gt;Nous l&amp;rsquo;avons jusque-là sous-entendu, les fichiers sous Linux sont dotés de permissions (que nous appellerons aussi &amp;ldquo;&lt;em&gt;droits&lt;/em&gt;&amp;rdquo;). Entrons à présent dans les détails pour découvrir ce que cela implique.&lt;/p&gt;

&lt;p&gt;3 opérations seulement sont permises sur les fichiers, &lt;strong&gt;la lecture, l&amp;rsquo;écriture, et l&amp;rsquo;exécution&lt;/strong&gt;, chacune de ces opérations disposant de droits indépendants. La commande &lt;strong&gt;ls&lt;/strong&gt; avec l&amp;rsquo;option &lt;strong&gt;-l&lt;/strong&gt; nous listera les fichiers avec certaines de leurs principales propriétés.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
drwxr-xr-x   2   zirka   admin    4096   mars   1 11:45   annexes
-r--r--r--   1   mary    mary     5769   mars  24 14:26   lfce-lfcs.md
-rwxrw-r--   1   zirka   admin    7201   avril 10 15:51   lfcs-commandline.md
-rw-rw-r--   1   jul     author   8710   avril 10 15:47   lfcs-navigate.md
-rwxrw-r--   1   zirka   admin    1236   avril 10 15:49   lfcs-rights.md
-rw-rw-r--   1   jul     author   3647   avril 10 14:45   lfcs-search.md
-rwxrw-r--   1   zirka   admin   10384   mars  24 09:49   pourquoi-golang.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On y retrouve dans la dernière colonne le nom de nos fichiers, précédé de sa date de dernière modification et de sa taille. En seconde position, un chiffre indique son nombre de liens, et est suivi de son &lt;strong&gt;groupe propriétaire&lt;/strong&gt; et de son &lt;strong&gt;utilisateur propriétaire&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;En première position, on trouve une chaine de caractères particulière. Le premier caractère désigne le &lt;strong&gt;type de fichier&lt;/strong&gt; (&lt;em&gt;-&lt;/em&gt; pour les fichiers réguliers, &lt;em&gt;d&lt;/em&gt; pour les répertoires, &lt;em&gt;l&lt;/em&gt; pour les liens symboliques). Les 9 autres caractères représentent les droit d&amp;rsquo;accès, avec &lt;strong&gt;r&lt;/strong&gt; signifiant &amp;ldquo;accesible en lecture&amp;rdquo; (readable), &lt;strong&gt;w&lt;/strong&gt; pour &amp;ldquo;accessible en écriture&amp;rdquo; (writable) et &lt;strong&gt;x&lt;/strong&gt; pour &amp;ldquo;accessible en exécution&amp;rdquo; (executable). Chaque groupe de 3 caractères représente les droits pour certains utilisateurs :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Les &lt;strong&gt;trois premiers&lt;/strong&gt; indiquent les droits pour &lt;strong&gt;l&amp;rsquo;utilisateur propriétaire&lt;/strong&gt; (user, colonne 3 avec &amp;ldquo;&lt;em&gt;ls -l&lt;/em&gt;&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;Les &lt;strong&gt;trois suivants&lt;/strong&gt; indiquent les droits pour les membres du &lt;strong&gt;groupe propriétaire&lt;/strong&gt; (group, colonne 4 avec &amp;ldquo;&lt;em&gt;ls -l&lt;/em&gt;&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;Les &lt;strong&gt;trois derniers&lt;/strong&gt; indiquent les droits pour les &lt;strong&gt;autres utilisateurs&lt;/strong&gt; (others).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ainsi, dans notre exemple précédent, le fichier &amp;ldquo;lfcs-navigate.md&amp;rdquo; sera totalement accessible pour l&amp;rsquo;utilisateur &amp;ldquo;zirka&amp;rdquo;, mais seulement en lercture/écriture pour les membres du groupe &amp;ldquo;admin&amp;rdquo; et seulement en lecture pour les autres. N&amp;rsquo;oublions pas que le superutilisateur a les droits d&amp;rsquo;accès complets (rwx) sur tous les fichiers de son système.&lt;/p&gt;

&lt;h2 id=&#34;gérer-les-droits&#34;&gt;Gérer les droits&lt;/h2&gt;

&lt;p&gt;Bien sûr, les permissions et propriétaires d&amp;rsquo;un fichier peuvent être changées. La commande &lt;strong&gt;chmod &lt;em&gt;p&lt;/em&gt; &lt;em&gt;f&lt;/em&gt;&lt;/strong&gt; permet de modifier les droits au fichier &lt;em&gt;f&lt;/em&gt;. &lt;em&gt;p&lt;/em&gt; prends alors la forme d&amp;rsquo;
une chaine de cactère avec un premier caractère &lt;strong&gt;u&lt;/strong&gt;, &lt;strong&gt;g&lt;/strong&gt; ou &lt;strong&gt;o&lt;/strong&gt; pour désigner la cible de ces droits (user, group ou others), un second caractère &lt;strong&gt;+&lt;/strong&gt; ou &lt;strong&gt;-&lt;/strong&gt; signifiant &amp;ldquo;ajouter&amp;rdquo; ou &amp;ldquo;retirer&amp;rdquo; les droits à la cible, et une suite de caractères &lt;strong&gt;r&lt;/strong&gt; et/ou &lt;strong&gt;w&lt;/strong&gt; et/ou &lt;strong&gt;x&lt;/strong&gt; pour désigner les droits concernés.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
-rwxrwxr--   1   moi   mongroupe   921   avril 10 15:47   test.txt

$ sudo chmod o+w test.txt
$ ls -l
-rwxrwxrw-   1   moi   mongroupe   921   avril 10 15:47   test.txt

$ sudo chmod g-wx test.txt
$ ls -l
-rwxr--rw-   1   moi   mongroupe   921   avril 10 15:47   test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Une autre méthode&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:6&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, dite numérique, consiste à fournir la liste complète des droits à affecter par une suite de trois chiffres les représentants. Chaque chiffre est alors la somme des droits voulus, avec :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4 : accès en lecture&lt;/li&gt;
&lt;li&gt;2 : accès en écriture&lt;/li&gt;
&lt;li&gt;1 : accès en exécution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Par l&amp;rsquo;exemple cela donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
-rwxr--rw-   1   moi   mongroupe   921   avril 10 15:47   test.txt

$ sudo chmod 754 test.txt
$ ls -l
-rwxr-xr--   1   moi   mongroupe   921   avril 10 15:47   test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous avons vu aujourd&amp;rsquo;hui les aspects fondamentaux de la gestion des droits dans un système Linux. Cependant, il reste bien des aspects et des commandes importantes que nous avons passé sous silence. Notre prochain article reviendra donc sur la question, avec de nouvelles commandes et quelques conseils sur la question.&lt;/p&gt;

&lt;!--
Ref : https://linuxjourney.com/lesson/file-permissions
--&gt;

&lt;!-- sudo --&gt;

&lt;!-- uname -a --&gt;

&lt;!-- Linux Epinet 3.13.0-93-generic #140-Ubuntu SMP Mon Jul 18 21:21:05 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux --&gt;

&lt;!--   A      B         C                                D                          E      F      G      H      --&gt;

&lt;!-- A = kernel name ; B = network node hostname ; C = kernel release ; D = kernel version ; E = machine hardware name --&gt;

&lt;!-- F = processor type (non-portable) ; G = hardware platform (non-portable) ; H = operating system --&gt;

&lt;!-- shutdown --&gt;

&lt;!-- logout --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;À noter que sous Linux, il existe des utilisateurs autres que les personnes physiques utilisant le système. Il peut s&amp;rsquo;agit de &lt;a href=&#34;https://fr.wikipedia.org/wiki/Daemon_(informatique)&#34;&gt;démons&lt;/a&gt;, de processus fonctionnant en arrière-plan, etc.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;&lt;em&gt;sudo&lt;/em&gt; et &lt;em&gt;su&lt;/em&gt; sont en fait plus générales, et permettent de réaliser des actions pour n&amp;rsquo;importe quel utilisateur, l&amp;rsquo;administrateur étant celui choisi par défaut.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;Il est aussi possible d&amp;rsquo;utiliser la commande &lt;strong&gt;useradd&lt;/strong&gt;/&lt;strong&gt;userdel&lt;/strong&gt;/&lt;strong&gt;usermod&lt;/strong&gt;, qui créera/détruira/modifiera (on dossier personnel par exemple) elle aussi un utilisateur, mais sans effectuer cette liste d&amp;rsquo;actions.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Il s&amp;rsquo;agit en fait d&amp;rsquo;un &lt;a href=&#34;https://www.aychedee.com/2012/03/14/etc_shadow-password-hash-formats/&#34;&gt;hash du mot de passe&lt;/a&gt;. Cette opération est irréversible (il n&amp;rsquo;est pas possible d&amp;rsquo;obtenir le mot de passe à partir du hash).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;Une troisième méthode consiste à remplacer la liste complète des droits à affecter par &lt;a href=&#34;https://linuxjourney.com/lesson/modifying-permissions&#34;&gt;une suite de nombres les représentants&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Système de fichiers et liens</title>
      <link>https://zirkachok.github.io/2017/04/11/lfcs--syst%C3%A8me-de-fichiers-et-liens</link>
      <pubDate>Tue, 11 Apr 2017 15:59:20 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/04/11/lfcs--syst%C3%A8me-de-fichiers-et-liens</guid>
      <description>

&lt;!-- ê î ô û --&gt;

&lt;p&gt;On dit souvent que sous Unix et Linux&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, &amp;ldquo;tout est fichier&amp;rdquo;, car les répertoires, fichiers réguliers, etc. y sont représentés par des fichiers dont seul le type et le contenu changent. Dans cet article, nous allons vois plus en détail ce qu&amp;rsquo;il en est vraiment, et découvrir un autre type de fichier, les liens.&lt;/p&gt;

&lt;p&gt;Pour illustrer ces concepts pas toujours évidents à appréhender, je vous ai aussi préparé une analogie simple et facile à retenir : la bibliothèque.&lt;/p&gt;

&lt;!-- En fait, tout est représenté pour l&#39;utilisateur par des fichiers. Nous verrons plus en détail ce que cela implique dans un prochain article.  --&gt;

&lt;h1 id=&#34;tout-est-fichier&#34;&gt;Tout est fichier&lt;/h1&gt;

&lt;h2 id=&#34;représentation-des-fichiers&#34;&gt;Représentation des fichiers&lt;/h2&gt;

&lt;p&gt;Sous Linux, un fichier est représenté par son nom et ce qu&amp;rsquo;on appelle un &lt;strong&gt;Inode&lt;/strong&gt;. Un Inode est un espace mémoire contenant les informations essentielles du fichier (ses attributs), à savoir :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;son &lt;strong&gt;type&lt;/strong&gt; : &lt;em&gt;-&lt;/em&gt; pour un fichier régulier, &lt;em&gt;d&lt;/em&gt; pour un dossier, &lt;em&gt;l&lt;/em&gt; pour un lien, etc.&lt;/li&gt;
&lt;li&gt;le &lt;strong&gt;nombre de ses liens physiques&lt;/strong&gt; : il s&amp;rsquo;agit du nombre de noms désignant cet Inode.&lt;/li&gt;
&lt;li&gt;sa &lt;strong&gt;taille&lt;/strong&gt; : l&amp;rsquo;espace mémoire que le contenu du fichier lui-même occupe.&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;&lt;strong&gt;addresse mémoire&lt;/strong&gt; se son contenu.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;et d&amp;rsquo;autres informations comme :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;l&amp;rsquo;identifiant du propriétaire du fichier (UID) et du du groupe auquel appartient le fichier (GID).&lt;/li&gt;
&lt;li&gt;ses droits d&amp;rsquo;accès : plus à ce sujet dans mon articles sur les &lt;em&gt;utilisateurs et droits&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;son horodatage (dernier accès &lt;em&gt;atime&lt;/em&gt;, modification &lt;em&gt;mtime&lt;/em&gt;, et modification de l&amp;rsquo;inode &lt;em&gt;ctime&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ainsi, un répertoire est considéré comme tout autre fichier régulier, à ceci près que son &lt;em&gt;type&lt;/em&gt; est différent (&lt;em&gt;d&lt;/em&gt; dans ce cas). Aussi, le &amp;ldquo;contenu&amp;rdquo; d&amp;rsquo;un répertoire est une table d&amp;rsquo;association entre des noms (les fichiers contenus dans le répertoire) et des inodes. De la même manière, un dispositif de communication (un périphérique ou du matériel, par exemple) sera lui aussi représenté par un fichier (de type &lt;em&gt;p&lt;/em&gt;), etc. Il est possible d&amp;rsquo;utiliser la commande &lt;strong&gt;ls&lt;/strong&gt; avec l&amp;rsquo;option &lt;strong&gt;-i&lt;/strong&gt; pour obtenir le numéro d&amp;rsquo;inode d&amp;rsquo;un fichier.&lt;/p&gt;

&lt;p&gt;Pour l&amp;rsquo;utilisateur, tout est donc représenté par des fichiers&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, qui suivent une certaine organisation : le système de fichier.&lt;/p&gt;

&lt;h2 id=&#34;le-système-de-fichiers&#34;&gt;Le système de fichiers&lt;/h2&gt;

&lt;p&gt;Le système de fichier est une représentation de l&amp;rsquo;arborescence, stockée en mémoire selon une certaine norme. Sous Linux, le système de fichiers contient un index de l&amp;rsquo;ensemble des inodes, suivi du contenu de contenu de chaque inode. L&amp;rsquo;inode 2 est la racine de l&amp;rsquo;arborescence[^3], et il est facile à partir de là d&amp;rsquo;en déduire récursivement l&amp;rsquo;ensemble de l&amp;rsquo;arborescence. C&amp;rsquo;est le principe défini par la norme &lt;strong&gt;Ext&lt;/strong&gt; (pour &lt;em&gt;Extended File System&lt;/em&gt;), dont la version la plus récente est l&amp;rsquo;&lt;strong&gt;Ext4&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il existe bien d&amp;rsquo;autres normes de systèmes de fichiers, chacune ayant ses spécificités. Les plus courantes sont &lt;strong&gt;FAT&lt;/strong&gt; (pour &lt;em&gt;File Allocation Table&lt;/em&gt;), &lt;strong&gt;NTFS&lt;/strong&gt; (pour &lt;em&gt;New Technology File System&lt;/em&gt;, utilisé par les systèmes Windows) et bien sûr &lt;strong&gt;Ext2&lt;/strong&gt;, &lt;strong&gt;Ext3&lt;/strong&gt; et &lt;strong&gt;Ext4&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Plusieurs systèmes de fichiers peuvent être &amp;ldquo;&lt;em&gt;montés&lt;/em&gt;&amp;rdquo; sur dans l&amp;rsquo;arborescence, et peuvent être listés à l&amp;rsquo;aide de la commande &lt;strong&gt;df -T&lt;/strong&gt;. Nous verrons plus en détail dans un autre article comment monter, démonter et gérer ces différents systèmes de fichiers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ df -T
Sys. de fichiers             Type       blocs de 1K    Utilisé Disponible Uti% Monté sur
udev                         devtmpfs       1942644          0    1942644   0% /dev
tmpfs                        tmpfs           391780       6224     385556   2% /run
/dev/sda7                    ext4          57542652   47442952    7153652  87% /
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;!--
Ref : http://www.linux-france.org/article/dalox/unix02.htm
      http://zero202.free.fr/cs3-svsf/html/ar01s02.html
      https://doc.ubuntu-fr.org/systeme_de_fichiers
      http://www.linux-france.org/article/kafkafr/node19.html
      http://formation-debian.via.ecp.fr/filesystem.html
      https://fr.wikipedia.org/wiki/N%C5%93ud_d%27index
      https://forum.ubuntu-fr.org/viewtopic.php?id=282989
      http://www.funix.org/fr/unix/fichiers.htm
--&gt;

&lt;h1 id=&#34;les-liens&#34;&gt;Les liens&lt;/h1&gt;

&lt;p&gt;Maintenant qua nous avons vu ce que sont les inodes et comment ils sont gérés, nous pouvons aborder le concept de &lt;strong&gt;liens&lt;/strong&gt;. Un lien est un type de fichier spécifique, qui sert d&amp;rsquo;alias pour un autre. Il fait donc référence à ce dernier, situé ailleurs dans le système de fichiers. En pratique, il existe deux types de liens : les &lt;strong&gt;liens physiques&lt;/strong&gt; (&lt;em&gt;hard links&lt;/em&gt; en Anglais), et les &lt;strong&gt;liens symboliques&lt;/strong&gt; (&lt;em&gt;soft links&lt;/em&gt;, &lt;em&gt;symbolic links&lt;/em&gt; ou &lt;em&gt;symlinks&lt;/em&gt; en Anglais). Voyons-en les particularités.&lt;/p&gt;

&lt;h2 id=&#34;liens-physiques&#34;&gt;Liens physiques&lt;/h2&gt;

&lt;p&gt;Un fichier de lien physique et le fichier régulier auquel il est lié sont tous deux associés au &lt;strong&gt;même inode&lt;/strong&gt;. Ainsi, la suppression d&amp;rsquo;un de ces deux fichiers ne détruira pas l&amp;rsquo;autre (l&amp;rsquo;inode sera toujours accessible tant qu&amp;rsquo;un nom de fichier y est associé), et la modification de l&amp;rsquo;un entrainera la modification de l&amp;rsquo;autre (car ce sont les données dont l&amp;rsquo;addresse est contenue dans l&amp;rsquo;inode qui sont alors modifiées).&lt;/p&gt;

&lt;p&gt;Dans la pratique, c&amp;rsquo;est la commande &lt;strong&gt;ln&lt;/strong&gt; qui permet de créer des liens (les lignes commencant par &lt;strong&gt;#&lt;/strong&gt; sont des commentaires) :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat hell.txt
Living easy, living free
Season ticket on a one-way ride
[...]

$ ln hell.txt hell_link.txt

$ ls -i
666 hell.txt  666 hell_link.txt

cat hell_link.txt
Living easy, living free
Season ticket on a one-way ride
[...]

# Imagineons que l&#39;on change maintenant le contenu de hell.txt
$ cat hell.txt
No stop signs, speed limit
Nobody is gonna slow me down
[...]

$ cat hell_link.txt
No stop signs, speed limit
Nobody is gonna slow me down
[...]

$ rm hell.txt

$cat hell_link.txt
No stop signs, speed limit
Nobody gonna slow me down
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;liens-symboliques&#34;&gt;Liens symboliques&lt;/h2&gt;

&lt;p&gt;Au contraire, un lien symbolique ressemble plutôt à un raccourci. Un fichier de lien sybolique symbolique aura son inode distinct, dont l&amp;rsquo;addresse vers le contenu désignera l&amp;rsquo;inode du fichier auquel il est lié, et non plus son contenu. Ainsi, détruire le fichier original rendra la lecture ou la modification du lien symbolique impossible.&lt;/p&gt;

&lt;p&gt;Là encore, c&amp;rsquo;est la commande &lt;strong&gt;ln&lt;/strong&gt; qui crée des liens, qui seront des liens symboliques avec l&amp;rsquo;option &lt;strong&gt;-s&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat hell.txt
Living easy, living free
Season ticket on a one-way ride
[...]

$ ln -s hell.txt hell_link.txt

$ ls -i
666 hell.txt  426 hell_link.txt

cat hell_link.txt
Living easy, living free
Season ticket on a one-way ride
[...]

# Imagineons que l&#39;on change maintenant le contenu de hell.txt
$ cat hell.txt
No stop signs, speed limit
Nobody is gonna slow me down
[...]

$ cat hell_link.txt
No stop signs, speed limit
Nobody is gonna slow me down
[...]

$ rm hell.txt

$cat hell_link.txt
cat: hell_link.txt: Aucun fichier ou dossier de ce type
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;l-analogie-de-la-bibliothèque&#34;&gt;L&amp;rsquo;analogie de la bibliothèque&lt;/h1&gt;

&lt;p&gt;Un moyen simple de comprendre le fonctionnement d&amp;rsquo;un système de fichiers est d&amp;rsquo;en faire l&amp;rsquo;analogie avec un bibliothèque. La bibliothèque dispose d&amp;rsquo;un index classant les fiches de chaque livre disponible. Une fiche décrit sommairement le livre (le genre littéraire, le nombre de pages) et en contient l&amp;rsquo;emplacement dans la bibliothèque. Vous l&amp;rsquo;aurez compris, notre bibliothèque représente le système de fichiers, et les fiches sont nos inodes (dont le contenu est d&amp;rsquo;ailleurs similaire).&lt;/p&gt;

&lt;p&gt;Un même livre peut être désigné par deux fiches distinctes. Dans ce cas, la destruction d&amp;rsquo;une des fiche n&amp;rsquo;impacte pas l&amp;rsquo;autre (le livre n&amp;rsquo;a pas changé de place ou de contenu, l&amp;rsquo;autre fiche est donc toujours valide). C&amp;rsquo;est sur ce modèle que fonctionnent les liens physiques.
Une fiche peut aussi renvoyer à une autre fiche existante. Dans ce cas, la destruction de cette dernière rendra la première invalide (car à partir de la référence, on ne pourra plus trouver le livre). C&amp;rsquo;est ainsi que fonctionnent les liens symboliques.&lt;/p&gt;

&lt;!-- 
un symlink c&#39;est different dans le sens ou, le fichier original va pointer sur l&#39;inode contenant la data,
et le symlink va pointer lui sur un inode dont la data correspond au chemin du fichier original !
ce qui fais que lorsque tu détruit le fichier original, le symlink est cassé !  --&gt;

&lt;!-- uname -a --&gt;

&lt;!-- Linux Epinet 3.13.0-93-generic #140-Ubuntu SMP Mon Jul 18 21:21:05 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux --&gt;

&lt;!--   A      B         C                                D                          E      F      G      H      --&gt;

&lt;!-- A = kernel name ; B = network node hostname ; C = kernel release ; D = kernel version ; E = machine hardware name --&gt;

&lt;!-- F = processor type (non-portable) ; G = hardware platform (non-portable) ; H = operating system --&gt;

&lt;!-- shutdown --&gt;

&lt;!-- logout --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Dans cet article, je généraliserai Unix et Linux en ne désignant que Linux, mais tous deux suivent la même philosophie.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Le noyau Linux quant à lui gère les choses différemment, mais c&amp;rsquo;est une toute autre question.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Effectuer des recherches dans l&#39;arborescence</title>
      <link>https://zirkachok.github.io/2017/04/10/lfcs--effectuer-des-recherches-dans-larborescence</link>
      <pubDate>Mon, 10 Apr 2017 13:48:16 +0200</pubDate>
      
      <guid>https://zirkachok.github.io/2017/04/10/lfcs--effectuer-des-recherches-dans-larborescence</guid>
      <description>&lt;!-- ê î ô --&gt;

&lt;p&gt;À ce stade là, nous savons déjà faire beaucoup de choses pour manipuler l&amp;rsquo;arborescence. Reste que lorsqu&amp;rsquo;on cherche un fichier précis sans savoir où il se trouve exactement, les choses se compliquent. C&amp;rsquo;est là que la commande &lt;strong&gt;locate&lt;/strong&gt; entre en jeu. Avec en argument un ou plusieurs motif(s), elle permet de lister tous les chemins contenant un des motifs en question. Quelques options permettent d&amp;rsquo;affiner ces recherches :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-i&lt;/strong&gt; ou &lt;strong&gt;--ignore-case&lt;/strong&gt; : De base, locate est sensible à la casse. L&amp;rsquo;option &lt;em&gt;-i&lt;/em&gt; enlève cette restriction.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-c&lt;/strong&gt; ou &lt;strong&gt;--count&lt;/strong&gt; : Plutôt que de lister les fichiers trouver, &lt;em&gt;locate&lt;/em&gt; en renverra le nombre.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-b&lt;/strong&gt; ou &lt;strong&gt;--basename&lt;/strong&gt; : Liste uniquement les fichiers dont le &lt;em&gt;nom&lt;/em&gt; contient le motif (et non plus le chemin).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-A&lt;/strong&gt; ou &lt;strong&gt;--all&lt;/strong&gt;  : Liste les chemins contenant &lt;em&gt;tous&lt;/em&gt; les motifs donnés (et non ceux en contenant au moins un).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Et par l&amp;rsquo;exemple, cela donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ locate zirka
/home/jul/Work/zirka.jpg
/home/jul/Desktop/zirka-listing.doc
/home/jul/Work/zirka/test1.data
/home/jul/Work/zirka/test2.data
[...]

$ locate -b zirka
/home/jul/Work/zirka.jpg
/home/jul/Desktop/zirka-listing.doc
[...]

$ locate zirka test
/home/jul/Work/zirka.jpg
/home/jul/Desktop/zirka-listing.doc
/home/jul/Work/zirka/test1.data
/home/jul/Work/zirka/test2.data
/home/jul/Work/tmp/test.txt
[...]

$ locate -A zirka test
/home/jul/Work/zirka/test1.data
/home/jul/Work/zirka/test2.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Par contre, pour des recherches plus précises et dans un dossier en particulier, on se tournera vers la commande &lt;strong&gt;find&lt;/strong&gt;. Elle prends en argument le chemin du dossier à partir duquel la recherche sera effectuée, et listera les fichiers présents dans le dossier et ses sous-dossiers. Il est aussi possible de lui spécifier des filtres avec les options, comme les quelques exemples suivants (plus de détails dans le manuel) :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-maxdepth &lt;em&gt;x&lt;/em&gt;&lt;/strong&gt; : Ne garde que les fichiers contenus dans une suite d&amp;rsquo;au plus &lt;em&gt;x&lt;/em&gt; dossiers (i.e. ayant une profondeur de &lt;em&gt;x&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-name &lt;em&gt;x&lt;/em&gt;&lt;/strong&gt; : Fichiers dont le nom est &lt;em&gt;x&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-type&lt;/strong&gt; : Filtre les fichiers par type

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-type d&lt;/strong&gt; pour les dossiers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-type f&lt;/strong&gt; pour les fichiers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-type l&lt;/strong&gt; pour les liens&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-ctime&lt;/strong&gt; : Filtre les fichiers par date de création. Il existe aussi les commandes similaires &lt;strong&gt;-mtime&lt;/strong&gt; et &lt;strong&gt;-atime&lt;/strong&gt;, qui filtrent respectivement par date de dernière modification ou de dernier accès.

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-ctime &lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; pour les fichiers créés il y a exactement &lt;em&gt;n&lt;/em&gt; jours.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-ctime &lt;em&gt;+n&lt;/em&gt;&lt;/strong&gt; pour les fichiers créés il y a plus de &lt;em&gt;n&lt;/em&gt; jours.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-ctime &lt;em&gt;-n&lt;/em&gt;&lt;/strong&gt; pour les fichiers créés il y a moins de &lt;em&gt;n&lt;/em&gt; jours.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-size&lt;/strong&gt; : Comme pour &lt;em&gt;-ctime&lt;/em&gt;, mais filtre par taille de fichiers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Et dans la pratique, cela donne:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pwd
/home/zirka/web-content

$ find .
.
./content
./content/test.txt
./content/post
./content/post/lfcs-navigate.md
./content/post/lfcs-commandline.md
./content/post/hello-world.md
./content/post/lfcs-search.md
./content/post/lfce-lfcs.md
./content/post/pourquoi-golang.md

$ find . -maxdepth 2
./content/test.txt

find . -type d
.
./content
./content/post

$ find . -mtime -1
./content
./content/post
./content/post/lfcs-commandline.md
./content/post/lfcs-search.md

find . -name test.txt
./content/test.txt

find . -name *golang.md
./content/post/pourquoi-golang.md
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Naviguer dans un système Linux</title>
      <link>https://zirkachok.github.io/2017/02/14/lfcs--naviguer-dans-un-syst%C3%A8me-linux</link>
      <pubDate>Tue, 14 Feb 2017 16:14:27 +0100</pubDate>
      
      <guid>https://zirkachok.github.io/2017/02/14/lfcs--naviguer-dans-un-syst%C3%A8me-linux</guid>
      <description>

&lt;p&gt;Maintenant que l&amp;rsquo;utilisation de la ligne de commande n&amp;rsquo;a plus de secret pour nous, il est temps de découvrir l&amp;rsquo;arborescence d&amp;rsquo;un système Linux et apprendre comment s&amp;rsquo;y orienter et naviguer dedans.&lt;/p&gt;

&lt;!-- Avant toute chose, je recommande d&#39;utiliser une Sandbox (un espace de test dédié et isolé) pour réaliser les exercices et manipulations de cette série. Comme nous allons être amenés à réaliser des manipulations plus ou moins critiques et à altérer le fonctionnement du système, le faire depuis son environnement de tous les jours peut s&#39;avérer risqué si vous ne savez pas exactement ce que vous faites. --&gt;

&lt;div class=&#34;warning&#34;&gt;Il s&#39;agit ici d&#39;une introduction destinée aux débutants. Pour ceux d&#39;entre vous déjà familiers avec la ligne de commande, vous y apprendrez peut-être quelque chose, ou peut-être pas, mais dans tous les cas vous pouvez passer sans scrupules à un article plus avancé.&lt;/div&gt;

&lt;h1 id=&#34;l-arborescence&#34;&gt;L&amp;rsquo;arborescence&lt;/h1&gt;

&lt;p&gt;Linux repose sur une arborescence pour organiser les fichiers au sein du système&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Chaque fichier ou dossier se situe donc virtuellement dans une succession de répertoires, remontant jusqu&amp;rsquo;à la racine du système de fichiers (dénommée &amp;ldquo; / &amp;ldquo;): c&amp;rsquo;est ce qu&amp;rsquo;on appelle le &lt;strong&gt;chemin absolu&lt;/strong&gt;. Par simplicité, cette arborescence est souvent représentée comme un arbre inversé, avec la racine au sommet. Le dossier dans lequel vous vous trouvez est quand à lui appelé &lt;strong&gt;dossier courant&lt;/strong&gt; (ou &amp;ldquo;Working directory&amp;rdquo;), et il est aussi possible de représenter un chemin à partir de cet endroit: c&amp;rsquo;est alors un &lt;strong&gt;chemin relatif&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Dans cet exemple, le &lt;span style=&#34;color:blue&#34;&gt;chemin absolu vers le dossier &amp;ldquo;rainbow&amp;rdquo;&lt;/span&gt; est &amp;ldquo; &lt;em&gt;/home/zirka/somewhere/over/rainbow&lt;/em&gt; &amp;ldquo; . Comme le &lt;span style=&#34;color:magenta&#34;&gt;dossier courant&lt;/span&gt; est &amp;ldquo;zirka&amp;rdquo; (dont le chemin absolu est &amp;ldquo; &lt;em&gt;/home/zirka&lt;/em&gt; &amp;ldquo;), le &lt;span style=&#34;color:red&#34;&gt;chemin relatif vers le dossier &amp;ldquo;&lt;em&gt;rainbow&lt;/em&gt;&amp;ldquo;&lt;/span&gt; est &amp;ldquo; &lt;em&gt;somewhere/over/rainbow&lt;/em&gt; &amp;ldquo; .&lt;/p&gt;

&lt;h2 id=&#34;s-orienter-et-se-déplacer&#34;&gt;S&amp;rsquo;orienter et se déplacer&lt;/h2&gt;

&lt;p&gt;Dans la pratique, un certain nombre de commandes nous permettent de nous orienter et nous déplacer dans le système de fichier, en ligne de commande. Commençons par découvrir l&amp;rsquo;arborescence :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pwd&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Print Working Directory&lt;/em&gt;&amp;rdquo;) : retourne le chemin absolu du dossier courant&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ls&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;LiSt directory content&lt;/em&gt;&amp;rdquo;) : liste les fichiers &amp;amp; dossiers situés dans le dossier courant&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tree&lt;/strong&gt; : retourne une vue graphique de l&amp;rsquo;arborescence à partir du chemin courant&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pour toutes ces commandes, il est aussi possible de passer en argument un chemin donné, pour que l&amp;rsquo;opération soit effectuée à partir de ce dossier.&lt;/p&gt;

&lt;p&gt;Au passage, il est possible avec ls et bien d&amp;rsquo;autres commandes (find, file, etc.) de donner des &lt;strong&gt;motifs &amp;ldquo;abstraits&amp;rdquo;&lt;/strong&gt; plutôt qu&amp;rsquo;un nom précis. Sans entrer dans les détails, il est possible d&amp;rsquo;utiliser le caractère &lt;strong&gt;*&lt;/strong&gt; pour désigner &amp;ldquo;tout&amp;rdquo;. Par exemple, la commande &amp;ldquo; &lt;em&gt;ls *.bin&lt;/em&gt; &amp;ldquo; listera tous les fichiers dont le nom finit par &lt;em&gt;.bin&lt;/em&gt; .&lt;/p&gt;

&lt;p&gt;Enfin, c&amp;rsquo;est la commande &lt;strong&gt;cd&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Change Directory&lt;/em&gt;&amp;rdquo;) qui nous permet de nous déplacer. Si elle n&amp;rsquo;est pas complétée d&amp;rsquo;un argument, elle nous amènera directement au répertoire par défaut. Le plus souvent, il s&amp;rsquo;agit du répertoire personnel de l&amp;rsquo;utilisateur courant, dont le chemin par défaut est &amp;ldquo; &lt;em&gt;/home/username&lt;/em&gt; &amp;ldquo; avec &lt;em&gt;username&lt;/em&gt; le nom de l&amp;rsquo;utilisateur. Il est aussi possible de donner à &lt;em&gt;cd&lt;/em&gt; un chemin absolu ou relatif au dossier courant pour s&amp;rsquo;y déplacer.&lt;/p&gt;

&lt;p&gt;À noter qu&amp;rsquo;il existe aussi certains raccourcis, comme :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;rdquo; &lt;em&gt;~&lt;/em&gt; &amp;ldquo; pour le répertoire personnel de l&amp;rsquo;utilisateur courant&lt;/li&gt;
&lt;li&gt;&amp;rdquo; &lt;em&gt;.&lt;/em&gt; &amp;ldquo; pour le répertoire courant&lt;/li&gt;
&lt;li&gt;&amp;rdquo; &lt;em&gt;..&lt;/em&gt; &amp;ldquo; pour le répertoire parent (celui qui contient le dossier courant)&lt;/li&gt;
&lt;li&gt;&amp;rdquo; &lt;em&gt;-&lt;/em&gt; &amp;ldquo; pour le répertoire précédent (celui où vous étiez avant le dernier déplacement)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cela nous donne donc via le terminal (les commandes que nous entrons sont ici précédées du symbole &amp;ldquo;$&amp;rdquo;) :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pwd
/home/zirka

$ tree 
.
├── config.xml
├── somewhere
│   └── over
│       └── rainbow
│           ├── high.c
│           ├── up.mk
│           └── way.c

$ ls
somewhere

$ ls somewhere/over/rainbow
high.c  up.mk  way.c

$ ls ~/somewhere/over/rainbow
high.c  up.mk  way.c

$ cd /home/zirka/somewhere/over/rainbow
$ ls
high.c  up.mk  way.c

$ ls *.c
high.c  way.c
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- &lt;span style=&#34;color:red&#34;&gt;!!! **Important !!!**&lt;/span&gt; Lorsque vous avez un doute sur l&#39;utilisation d&#39;une commande, la commande **man** suivie du nom de celle recherchée (e.g. *man pwd* ) vous affichera une page d&#39;aide, avec son utilisation, ses options, etc. --&gt;

&lt;h2 id=&#34;créer-et-détruire&#34;&gt;Créer et détruire&lt;/h2&gt;

&lt;p&gt;Nous avons vu comment naviguer dans l&amp;rsquo;arborescence, reste maintenant à créer, déplacer, éditer et détruire des fichiers. Commencons par la création et le déplacement. Cela se passe avec les commandes suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mkdir&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Make Directory&lt;/em&gt;&amp;rdquo;) : permet de créer un répertoire avec pour chemin celui donné en argument&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;touch&lt;/strong&gt; : crée un fichier avec pour chemin celui donné en argument &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cp&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Copy&lt;/em&gt;&amp;rdquo;) : permet de copier un fichier d&amp;rsquo;un chemin vers un autre.

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;-r&lt;/em&gt; : avec l&amp;rsquo;option &amp;ldquo; &lt;em&gt;-r&lt;/em&gt; &amp;ldquo; (pour recursive), copie un dossier et tout son contenu.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mv&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Move&lt;/em&gt;&amp;rdquo;) : déplace un fichier d&amp;rsquo;un chemin vers un autre. À noter que mv peut aussi être utilisé pour renommer un fichier/dossier.

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;-r&lt;/em&gt; : avec l&amp;rsquo;option &amp;ldquo; &lt;em&gt;-r&lt;/em&gt; &amp;ldquo;, permet de déplacer un dossier et tout son contenu.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cela nous donne donc via le terminal :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
├── config.xml
├── somewhere
│   └── over
│       └── rainbow
│           ├── high.c
│           ├── up.mk
│           └── way.c

$ mkdir highway
$ mkdir highway/to
$ touch highway/to/hell.txt
$ cp highway/to/hell.txt somewhere/over/rainbow
$ mv somewhere/over/rainbow/up.mk highway/to/hell.txt

$ tree
.
├── config.xml
├── highway
│   └── to
│       ├── hell.txt
│       └── up.mk
├── somewhere
│   └── over
│       └── rainbow
│           ├── hell.txt
│           ├── high.c
│           └── way.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voyons maintenant comment détruire des fichiers ou dossiers. Pour cela rien de plus simple, avec les commandes suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;rm&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Remove&lt;/em&gt;&amp;rdquo;) : supprime définitivement un fichier via le chemin passé en argument.

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;-r&lt;/em&gt; : avec l&amp;rsquo;option &lt;em&gt;-r&lt;/em&gt;, efface un dossier et tout son contenu&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rmdir&lt;/strong&gt; (pour &amp;ldquo;&lt;em&gt;Remove Directory&lt;/em&gt;&amp;rdquo;) : efface définitivement un dossier via le chemin passé en argument.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En pratique, cela nous donne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
├── config.xml
├── highway
│   └── to
│       ├── hell.txt
│       └── up.mk
├── somewhere
│   └── over
│       └── rainbow
│           ├── hell.txt
│           ├── high.c
│           └── way.c

$ rm highway/to/hell.txt
$ rm highway/to/up.mk
$ rmdir highway/to
$ rm -r somewhere/over
$ touch highway/to/hell.txt
$ cp highway/to/hell.txt somewhere/over/rainbow
$ mv somewhere/over/rainbow/up.mk highway/to/hell.txt

$ tree
.
├── config.xml
└── somewhere
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous arrivons maintenant à la fin de notre premier acticle d&amp;rsquo;une longue série dédiée aux certifications de la fondation Linux. Nous avons abordé une première partie des commandes essentielles à connaître pour utiliser le terminal, en passant en revue les moyens de se repérer, créer et détruire dans l&amp;rsquo;arborescence Linux. Le prochain article complètera ce thème en abordant la question des liens, de la manipulation de fichiers, du manuel, et bien plus encore.&lt;/p&gt;

&lt;!--     Command Line

x   1. The Shell
x   2. pwd (Print Working Directory)
x   3. cd (Change Directory)
x   4. ls (List Directories)
x   5. touch
    6. file
    7. cat
    8. less
    9. history
x   10. cp (Copy)
x   11. mv (Move)
x   12. mkdir (Make Directory)
x   13. rm (Remove)
    14. find
    15. help
    16. man
    17. whatis
    18. alias
    19. exit

 --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Cette arborescence suit elle même une norme (le &amp;ldquo;Filesystems Hierarchy Standard&amp;rdquo;, FHS), que nous passerons au crible dans un article dédié.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;En fait, &amp;ldquo; &lt;em&gt;touch&lt;/em&gt; &amp;ldquo; permet de changer les dates d&amp;rsquo;un fichier (création, modification, etc.). Mais si ce fichier n&amp;rsquo;existe pas, il va le créer. À ma connaissance, il n&amp;rsquo;existe pas de commande dédiée pour créer un fichier.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LFCS : Dompter la ligne de commande</title>
      <link>https://zirkachok.github.io/2017/02/12/lfcs--dompter-la-ligne-de-commande</link>
      <pubDate>Sun, 12 Feb 2017 16:14:27 +0100</pubDate>
      
      <guid>https://zirkachok.github.io/2017/02/12/lfcs--dompter-la-ligne-de-commande</guid>
      <description>

&lt;!-- ê î ô --&gt;

&lt;p&gt;Pour bien débuter ma série d&amp;rsquo;articles concernant Linux, son fonctionnement et son administration, je vous propose de nous plonger dans la fameuse ligne de commande pour en découvrir l&amp;rsquo;intérêt et le fonctionnement. Et en bonus, je vous livrerai quelques conseils pour y être plus rapide et efficace!&lt;/p&gt;

&lt;!-- je vais passer en revue les commandes et rde bases nécessaires pour s&#39;orienter et naviguer au sein du système de fichiers. Je parle bien de &#34;commandes&#34;, car ici comme dans toute la suite, nous passerons par la ligne de commande. --&gt;

&lt;!-- Avant toute chose, je recommande d&#39;utiliser une Sandbox (un espace de test dédié et isolé) pour réaliser les exercices et manipulations de cette série. Comme nous allons être amenés à réaliser des manipulations plus ou moins critiques et à altérer le fonctionnement du système, le faire depuis son environnement de tous les jours peut s&#39;avérer risqué si vous ne savez pas exactement ce que vous faites. --&gt;

&lt;!-- Ceci étant dit, plongeons nous dans cette fameuse ligne de commande, et voyons commant nous repérer et naviguer dans un système Linux.  --&gt;

&lt;div class=&#34;warning&#34;&gt;Il s&#39;agit ici d&#39;une introduction destinée aux débutants. Pour ceux d&#39;entre vous déjà familiers avec la ligne de commande, vous y apprendrez peut-être quelque chose, ou peut-être pas, mais dans tous les cas vous pouvez passer sans scrupules à un article plus avancé.&lt;/div&gt;

&lt;h1 id=&#34;la-ligne-de-commande-c-est-quoi&#34;&gt;La ligne de commande, c&amp;rsquo;est quoi?&lt;/h1&gt;

&lt;p&gt;L&amp;rsquo;interpréteur de commandes (aussi appelé &amp;ldquo;ligne de commande&amp;rdquo;) permet d&amp;rsquo;accéder aux fonctions essentielles du système d&amp;rsquo;exploitation, par le biais de &lt;strong&gt;commandes&lt;/strong&gt; données en entrée (dans notre cas, tapées au clavier). Parmi ces fonctions, on retrouve par exemple la manipulation de fichiers, le déplacement dans l&amp;rsquo;arborescence, la lecture du manuel et de l&amp;rsquo;aide, et bien d&amp;rsquo;autres fonctionnalités.&lt;/p&gt;

&lt;h2 id=&#34;à-quoi-bon&#34;&gt;À quoi bon?&lt;/h2&gt;

&lt;p&gt;À première vue, l&amp;rsquo;intérêt de la ligne de commande n&amp;rsquo;est pas forcément évident, et les applications graphiques peuvent sembler tout aussi efficaces bien plus abordables&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Mais avec l&amp;rsquo;expérience, il est souvent bien plus rapide et efficace de gérer son système Linux de cette manière que graphiquement. La ligne de commande permet de réaliser dans les moindres détails &lt;strong&gt;toutes&lt;/strong&gt; les opérations permises par le système, alors que les outils graphiques ne peuvent réaliser que les opérations usuelles. Pour enfoncer le clou, dans le cas des serveurs entre autres il s&amp;rsquo;agit même d&amp;rsquo;un passage obligé (ils n&amp;rsquo;ont généralement pas de mode graphique). Alors pour un administrateur, un professionnel, ou un utilisateur averti et curieux, impossible d&amp;rsquo;y échapper, alors autant s&amp;rsquo;y mettre dès maintenant.&lt;/p&gt;

&lt;!-- ## sh, bash, zsh, ... --&gt;

&lt;p&gt;Il existe de nombreux interpréteurs, les plus courant étant le Bourne Shell (&lt;em&gt;sh&lt;/em&gt;), le Bourne-Again Shell (&lt;em&gt;bash&lt;/em&gt;), le Z shell (&lt;em&gt;zsh&lt;/em&gt;), etc. Chacun a ses particularités&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, mais inutiler pour le moment (sauf par curiosité) de les essayer tous. Utilisez le plus répendu actuellement (et par défaut sur de nombreuses distributions de Linux) : &lt;strong&gt;bash&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;gagner-en-efficacité&#34;&gt;Gagner en efficacité&lt;/h1&gt;

&lt;p&gt;Aussi pratique soit-elle, la ligne de commande demande de l&amp;rsquo;entraînement pour être &amp;ldquo;domptée&amp;rdquo;. Impossible de faire l&amp;rsquo;impasse sur la dactylographie et la mémorisation de toutes les commandes et leurs options (pas de panique, ça rentre tout seul avec la pratique), mais il existe aussi de nombreuses commandes et raccourcis pour nous faciliter le travail (et gagner en efficacité et rapidité).&lt;/p&gt;

&lt;h2 id=&#34;se-déplacer-dans-les-commandes&#34;&gt;Se déplacer dans les commandes&lt;/h2&gt;

&lt;p&gt;Il arrive souvent de devoir se déplacer dans une commande que l&amp;rsquo;on est en train de taper. Plutôt que d&amp;rsquo;effacer ou tout recommencer, quelques raccourcis bien pratique permettent de s&amp;rsquo;y déplacer en un clin d&amp;rsquo;oeil :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-a&lt;/strong&gt; et &lt;strong&gt;Ctrl-e&lt;/strong&gt; permettent respectivement de se rendre au début ou à la fin de la ligne courante.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt-b&lt;/strong&gt; et &lt;strong&gt;Alt-f&lt;/strong&gt; permettent de se déplacer vers la gauche ou la droite mot par mot. Il est aussi possible d&amp;rsquo;utiliser à la place &lt;strong&gt;Ctrl-&amp;larr;&lt;/strong&gt; et &lt;strong&gt;Ctrl-&amp;rarr;&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-c&lt;/strong&gt; permet d&amp;rsquo;effacer la ligne courante. &lt;strong&gt;Ctrl-l&lt;/strong&gt; ou la commande &lt;strong&gt;clear&lt;/strong&gt; permettent d&amp;rsquo;effacer complètement le terminal courant. Bien pratique pour y voir plus clair!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-Shift-c/x/v&lt;/strong&gt; remplacent les raccourcis habituels pour copier, couper et coller.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-u&lt;/strong&gt; efface tout ce qui se trouve à gauche du curseur, et &lt;strong&gt;Ctrl-y&lt;/strong&gt; le colle à nouveau à son emplacement courant.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- Ctrl+Alt+F1 entrer en mode ligne de commande seule (non-graphique) --&gt;

&lt;p&gt;Une autre fonctionnalité intéressante est l&amp;rsquo;auto-complétion. Lorsque l&amp;rsquo;on entre une commande, il est possible d&amp;rsquo;appuyer sur la touche &lt;strong&gt;Tab&lt;/strong&gt; pour que celle-ci soit automatiquement complétée. En appuyant deux fois sur &lt;em&gt;Tab&lt;/em&gt;, la liste des complétions possibles est retournée.&lt;/p&gt;

&lt;h2 id=&#34;parcourir-l-historique&#34;&gt;Parcourir l&amp;rsquo;historique&lt;/h2&gt;

&lt;p&gt;Sous Linux, les dernières commandes entrées sont mémorisées, et peuvent être parcourues à l&amp;rsquo;aide des flèches &lt;em&gt;haut&lt;/em&gt; et &lt;em&gt;bas&lt;/em&gt;. Il est aussi possible de parcourir l&amp;rsquo;historique, via la commande &lt;strong&gt;history&lt;/strong&gt;. Encore plus pratique, appuyer sur &lt;strong&gt;Ctrl-r&lt;/strong&gt; nous fait entrer dans un mode spécifique, qui parcours cet historique lorsque l&amp;rsquo;on tape une commande, et propose la dernière commande entrée similaire. Ce mode est particulièrement pratique lorsque l&amp;rsquo;on répète régulièrement les mêmes commandes.&lt;/p&gt;

&lt;h1 id=&#34;trouver-de-l-aide&#34;&gt;Trouver de l&amp;rsquo;aide&lt;/h1&gt;

&lt;p&gt;Il est juste impossible de mémoriser toutes les commandes, et il n&amp;rsquo;est pas rare que l&amp;rsquo;on ait besoin d&amp;rsquo;une aide pour en connaitre le fonctionnement et les options. Pour cela, il existe le manuel, accessible par la commande &lt;strong&gt;man&lt;/strong&gt; suivie de la commande cherchée. On entre alors dans une interface identique à celle de &lt;em&gt;less&lt;/em&gt;, avec une explication complète de la commande en question. N&amp;rsquo;hésitez pas à chercher la page de manuel des commandes que nous avons vu jusque là, pour vous familiariser avec cet outil.&lt;/p&gt;

&lt;p&gt;De manière générale, ayez le réflèxe de lire le manuel pour toute nouvelle commande. Vous pourrez constater certaines similitudes (fonctionnement, arguments, etc.), et elles deviendront vite plus facile à retenir.&lt;/p&gt;

&lt;p&gt;Essayez d&amp;rsquo;utiliser ces commandes et raccourcis lors de vos tests, exercices, ou simplement sans raison particulière et vous verrez, vous ne pourrez plus vous en passer. D&amp;rsquo;ailleurs, cela vaut aussi pour la ligne de commande elle-même, alors &lt;a href=&#34;https://fr.wikipedia.org/wiki/Jetzt_geht&#39;s_los&#34;&gt;Jetzt geht&amp;rsquo;s los&lt;/a&gt;!&lt;/p&gt;

&lt;!-- 
REFS :
    https://www.linux.com/learn/intro-to-linux/2017/4/fabulous-bash-navigation-shortcuts
 --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Et dans une certaine mesure le sont, quand on ne cherche à réaliser que des opérations courantes)
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Les différences majeures étant la conformité au standard &lt;a href=&#34;https://fr.wikipedia.org/wiki/POSIX&#34;&gt;POSIX&lt;/a&gt; et quelques fonctionnalités supplémentaires (e.g. le changement automatique de répertoire avec zsh). Je reviendrai sur ces différences dans un prochain article.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Linux a 25 ans, il est temps de se certifier!</title>
      <link>https://zirkachok.github.io/2017/01/20/linux-a-25-ans-il-est-temps-de-se-certifier</link>
      <pubDate>Fri, 20 Jan 2017 16:01:18 +0100</pubDate>
      
      <guid>https://zirkachok.github.io/2017/01/20/linux-a-25-ans-il-est-temps-de-se-certifier</guid>
      <description>

&lt;p&gt;Linux fête cette année ses 25 ans, autant d&amp;rsquo;années pendant lesquelles nous l&amp;rsquo;avons vu prendre du poids. Son influence s&amp;rsquo;est tout particulièrement faite remarquer dans les secteurs ayant subi d&amp;rsquo;importantes transformations, tels que l&amp;rsquo;embarqué, le Cloud ou les smartphones, où il est devenu un acteur essentiel. Même les architectures mainframe commencent à lorgner de son côté&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, tout un symbole.&lt;/p&gt;

&lt;p&gt;Avec cet essor, Linux a aussi beaucoup gagné en reconnaissance et en ouverture au public. Les livres et tutoriels à son sujet sont maintenant légion, et de nombreuses entreprises sont demandeuses de profils experts en développement ou administration de tels systèmes. Linux est donc devenu un incontournable pour la plupars des ingénieurs informatique, mais il reste malgré tout pour beaucoup assez méconnu.&lt;/p&gt;

&lt;h1 id=&#34;mettre-en-avant-son-expertise&#34;&gt;Mettre en avant son expertise&lt;/h1&gt;

&lt;p&gt;Utilisateur quotidien d&amp;rsquo;environnements Linux allant de sytèmes embarqués minimalistes et serveurs dans le cadre de mon travail, aux distributions graphiques &amp;ldquo;classiques&amp;rdquo; sur mon ordinateur personnel, j&amp;rsquo;ai depuis mes débuts été versé dans ce domaine. Pourtant, il m&amp;rsquo;a aussi souvent été difficile de mettre en avant cette expertise et me différencier. La faute au fait que souvent, il est nécessaire de convaincre ses interlocuteurs rapidement, sans engager une conversation technique de haute volée&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Et à ce niveau, seuls deux critères comptent : l&amp;rsquo;expérience et les diplômes/certifications.&lt;/p&gt;

&lt;p&gt;Depuis 2014, la Fondation Linux&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; a lancé un programme destiné à former des ingénieurs et administrateurs système sur le système Linux, ainsi que des certifications reconnues dans ce domaine, les &lt;a href=&#34;https://training.linuxfoundation.org/certification/lfcs&#34;&gt;LFCS&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://training.linuxfoundation.org/certification/lfce&#34;&gt;LFCE&lt;/a&gt; (Linux Foundation Certified Sysadmin &amp;amp; Engineer)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;. Ces certifications rejoignent ainsi celles proposées par Red-Hat, qui ont peinent à gagner en reconnaissance du fait de leur spécificité, et offrent une sorte d&amp;rsquo;équivalent à celles proposées par Microsoft pour son système Windows.&lt;/p&gt;

&lt;p&gt;D&amp;rsquo;un point de vue pratique, les examens de certification se font à distance, contrôlés par la fondation Linux. Une évaluation est donnée suivant un barème précis, en suivant un programme public, offrant un certain gage de qualité et de transparence. Cette évaluation permet d&amp;rsquo;ailleurs aussi de se faire une idée assez précise du niveau de la personne. Le &lt;a href=&#34;https://training.linuxfoundation.org/certification/lfce&#34;&gt;programme&lt;/a&gt; est complet, et couvre la majorité des situations auxquelles peuvent être confronté un ingénieur dans son travail avec Linux. Une bonne nouvelle en somme, qui pourra permettre de mettre en avant de manière claire et transparente ses compétences.&lt;/p&gt;

&lt;h1 id=&#34;construire-ses-compétences&#34;&gt;Construire ses compétences&lt;/h1&gt;

&lt;p&gt;Mais revenons-en à moi quelques instants. J&amp;rsquo;avais accueilli avec beaucoup d&amp;rsquo;enthousiasme la naissance de ces certifications, et après avoir attendu les premiers retours à leur sujet, j&amp;rsquo;ai décidé de m&amp;rsquo;y plonger cette année. Et pour ne pas faire les choses à moitié, je vais proposer dans ces colonnes chaque semaine un article-tutoriel sur un sujet particulier touchant à Linux. Cela aura pour avantage de m&amp;rsquo;inciter à faire des recherches à ce sujet et à les mettre en forme, une bonne résolution en plus formel en quelque sorte.&lt;/p&gt;

&lt;p&gt;Chaque article sera composé de trois parties. Tout d&amp;rsquo;abord, je parlerai du système lui-même, des choix qui l&amp;rsquo;ont guidé et des grandes figures qui l&amp;rsquo;ont influencé, pour ensuite présenter une ou plusieurs fonctionnalités, et enfin je vous proposerai quelques exercices pour approfondir ces nouvelles connaissances. Je mettrai aussi à jour un &lt;a href=&#34;https://zirkachok.github.io/2017/04/18/index-des-pr%C3%A9requis-lfcs-lfce&#34;&gt;index basé sur les compétences officiellement requises par la Fondation Linux&lt;/a&gt;, pour s&amp;rsquo;y retrouver plus facilement. Alors rendez-vous ces prochaines semaines pour en découvrir un peu plus sur ce formidable projet qu&amp;rsquo;est le système Linux.&lt;/p&gt;

&lt;!-- La fondation Linux propose même un grand choix de [formations](https://training.linuxfoundation.org/) en ligne sur des sujets aussi variés que l&#39;administration des systèmes ou les infrastructures Cloud. Enfin, la virtualisation et les services Cloud permettent de tester une distribution facilement et à moindre frais. Ainsi, toutes les conditions sont réunies pour apprendre Linux dans les meilleures conditions.

Les &#34;Infrastructure as a service&#34; ou IaaS, comme [Scaleway](http://scaleway.com/) par exemple.
--&gt;

&lt;!-- # Et les certifications dans tout ça?
Pour mettre en avant ses compétences, les certifications restent un instrument de choix. Cependant, autant Microsoft propose des certifications claires et reconnues pour ses systèmes Windows, Autant pour Linux les choses sont moins claires.

La fondation Linux a même lancé un programme destiné à former des ingénieurs et administrateurs système sur le système Linux, ainsi que des certifications reconnues dans ce domaine, les LFCS &amp; LFCE (Linux Foundation Certified Sysadmin &amp; Engineer).
 --&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;En témoignent des initiatives comme l&amp;rsquo;&lt;a href=&#34;https://www.openmainframeproject.org/&#34;&gt;Open Mainframe&lt;/a&gt;, soutenue par IBM et Hitachi entre autres.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Surtout lorsque Linux n&amp;rsquo;est pas bien connu par l&amp;rsquo;interlocuteur en question. On retrouve la plupart du temps en face de soi des responsables n&amp;rsquo;ayant que peu pied dans le technique, ou des &amp;ldquo;experts&amp;rdquo; pas nécessairement à jour avec la technologie.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Un consortium à but non lucratif dédié à promouvoir, protéger et standardiser Linux.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Outre les deux citées ici, la Fondation Linux propose un catalogue assez vaste de &lt;a href=&#34;https://training.linuxfoundation.org/&#34;&gt;formations&lt;/a&gt; en ligne sur des sujets aussi variés que l&amp;rsquo;administration des systèmes ou les infrastructures Cloud.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Quelques impressions sur le Go</title>
      <link>https://zirkachok.github.io/2017/01/18/quelques-impressions-sur-le-go</link>
      <pubDate>Wed, 18 Jan 2017 17:20:17 +0100</pubDate>
      
      <guid>https://zirkachok.github.io/2017/01/18/quelques-impressions-sur-le-go</guid>
      <description>

&lt;p&gt;Il y a de cela des années, j&amp;rsquo;avais opté pour python comme language de prédilection pour mes développements débarqués. J&amp;rsquo;étais à l&amp;rsquo;époque tombé sous le charme de sa syntaxe minimaliste, de son efficacité (dans le traitement des chaines de caractères notamment) et de l&amp;rsquo;étendue de ses librairies. Autant d&amp;rsquo;avantages qui me permettaient de réaliser rapidement et efficacement des outils là où mes langages de script ne suffisaient plus. Cependant, au fil des années, de nouvelles problématiques m&amp;rsquo;ont amené à me détourner petit à petit de ce langage&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. J&amp;rsquo;ai donc commencé à chercher si ce n&amp;rsquo;est un successeur au moins un complément.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; fait partie de ces langages &amp;ldquo;à la mode&amp;rdquo; ces dernières années (avec &lt;a href=&#34;https://www.scala-lang.org/&#34;&gt;Scala&lt;/a&gt;, &lt;a href=&#34;https://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt;, &lt;a href=&#34;http://dlang.org/&#34;&gt;D&lt;/a&gt;, etc.), mais il se démarque par sa croissance&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; et ses origines&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Je me suis donc laissé tenter, et vous fait part de mes impressions après quelques semaines d&amp;rsquo;utilisation.&lt;/p&gt;

&lt;h1 id=&#34;une-philosophie-nouvelle&#34;&gt;Une philosophie nouvelle&lt;/h1&gt;

&lt;p&gt;Comme le jeu du même nom, Le langage Go a été conçu pour être simple à apprendre, mais profond dans ses possibilités. Celà se traduit par de nombreux aspects, assez novateurs dans le monde du développement.&lt;/p&gt;

&lt;h2 id=&#34;un-langage-rigide&#34;&gt;Un langage rigide&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Au premier regard, avec un typage fort et une syntaxe stricte, le Go semble assez rigide. Pas question ici de faire les choses à sa sauce. Les crochets suivent la déclaration des méthodes/fonctions/conditions/boucles sur la même ligne, il est interdit d&amp;rsquo;importer une bibliothèque sans l&amp;rsquo;appeler dans le code, toute variable a un type fixe, etc. Il existe même &lt;a href=&#34;https://blog.golang.org/go-fmt-your-code&#34;&gt;un outil&lt;/a&gt; fourni par défaut pour rendre conforme la syntaxe d&amp;rsquo;un code source en suivant les pratiques préconisées ou imposées.&lt;/p&gt;

&lt;p&gt;Un exemple de code en Go :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;flag&amp;quot;
)

func main() {
    var svar string
    wordPtr := flag.String(&amp;quot;file&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;a string&amp;quot;)

    flag.StringVar(&amp;amp;svar, &amp;quot;svar&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;a string var&amp;quot;)
    flag.Parse()

    if fileExists(*filePtr) {
        fmt.Println(&amp;quot;Valid file provided&amp;quot;)
    } else {
        fmt.Println(&amp;quot;File &amp;quot; + *filePtr + &amp;quot; not found&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cela peut sembler désagréable, surtout lorsque l&amp;rsquo;on est habitué à des langages plus permissifs (la plupart des langages en fait&amp;hellip;). Cependant, cette rigidité a pour avantage de forcer une uniformisation du code, et donc de faciliter grandement son inter-compréhension et son maintien. À ce niveau, le Go est particulièrement adapté aux projets de grande taille impliquant des développeurs d&amp;rsquo;expériences différentes (comme dans la communauté Open-Source, par exemple).&lt;/p&gt;

&lt;p&gt;Pour contrebalancer, La syntaxe du Go emprunte beaucoup au C/C++&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;, en y mêlant des éléments issus de langages plus récents. Elle se veut donc rassurante tout en étant moderne et puissante. Reste qu&amp;rsquo;une telle rigueur est un parti-pris qui ne plaira pas à tout le monde.&lt;/p&gt;

&lt;h2 id=&#34;et-flexible-à-la-fois&#34;&gt;&amp;hellip;Et flexible à la fois&lt;/h2&gt;

&lt;p&gt;Passée cette première impression, le Go fait preuve de nombreuses avantages. Comme citer ses qualités et inconvénients demanderait un article à lui seul (qui viendra peut-être, qui sait), je ne m&amp;rsquo;attarderai que sur ceux qui m&amp;rsquo;ont semblé les plus marquants :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Optimisé et optimisable&lt;/strong&gt; : Le langage Go, suivant le cas d&amp;rsquo;utilisation, n&amp;rsquo;est pas forcément le plus rapide ni le moins gourmand, comme le montrent les &lt;a href=&#34;https://days2011.scala-lang.org/sites/days2011/files/ws3-1-Hundt.pdf&#34;&gt;études&lt;/a&gt; sur le sujet. Par contre, outre la la présence d&amp;rsquo;un ramasse-miettes efficace, son utilisation du paradigme de programmation &lt;a href=&#34;https://blog.golang.org/concurrency-is-not-parallelism&#34;&gt;concurrente&lt;/a&gt; fait qu&amp;rsquo;il peut tirer le meilleur parti d&amp;rsquo;une architecture muti-coeurs sans perdre en qualité et propreté de code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Intuitif&lt;/strong&gt; : Comme je l&amp;rsquo;ai mentionné plus avant, pour qui est versé dans le C, C++ ou Java, le Go s&amp;rsquo;apprend de manière intuitive. Sa syntaxe proche de ces langages, la &lt;a href=&#34;https://blog.golang.org/error-handling-and-go&#34;&gt;gestion des erreurs&lt;/a&gt; simple et élégente, l&amp;rsquo;import des packages (notamment possible &lt;a href=&#34;https://golang.org/doc/code.html#ImportPaths&#34;&gt;via leur URL&lt;/a&gt;) largement simplifié, rendent sa prise en main rapide et facile. Comparé à aux langages fonctionnels tels que &lt;a href=&#34;https://www.scala-lang.org/&#34;&gt;Scala&lt;/a&gt; ou à des syntaxes plus originales comme &lt;a href=&#34;https://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt;, Go permet une transition rapide et efficace. Un atout de poids lorsque l&amp;rsquo;on travaille en équipe.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Des outils pour tout&lt;/strong&gt; : Go propose une large panoplie d&amp;rsquo;outils intégrés qui apportent un réel plus au langage en tant que tel. On y trouve entre autres &lt;a href=&#34;https://blog.golang.org/godoc-documenting-go-code&#34;&gt;Go doc&lt;/a&gt; pour la documentation automatique de code, &lt;a href=&#34;https://blog.golang.org/introducing-gofix&#34;&gt;Gofix&lt;/a&gt; pour la mise à niveau de code source au fil des versions, &lt;a href=&#34;https://golang.org/cmd/go/#hdr-List_packages&#34;&gt;Go list&lt;/a&gt; pour la génération des graphes de dépendances du package, &lt;a href=&#34;https://blog.golang.org/profiling-go-programs&#34;&gt;Go pprof&lt;/a&gt; pour le profilage, &lt;a href=&#34;https://blog.golang.org/debugging-go-code-status-report&#34;&gt;GDB&lt;/a&gt; pour le déboguage, et bien d&amp;rsquo;autres encore&amp;hellip; Enfin, il jouis d&amp;rsquo;une communauté très active proposant des packages variés et puissants&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, le tout en plus de ceux proposés officiellement.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Orienté Back-End&lt;/strong&gt; : La gestion native et optimisée protocoles et standards de l&amp;rsquo;Internet (&lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;HTTP&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/golang.org/x/crypto/ssh&#34;&gt;SSH&lt;/a&gt;, &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34;&gt;JSON&lt;/a&gt;, &lt;a href=&#34;https://golang.org/pkg/encoding/xml/&#34;&gt;XML&lt;/a&gt;, &lt;a href=&#34;https://golang.org/pkg/database/sql/&#34;&gt;SQL&lt;/a&gt;, &lt;a href=&#34;https://golang.org/pkg/crypto/&#34;&gt;cryptographie&lt;/a&gt;, etc.) et sa gestion de la concurrence font du Go un langage de choix pour le développement Cloud et Back-end. Ce n&amp;rsquo;est pas pour rien que des fournisseur de services comme SendGrid, Docker ou encore Dropbox s&amp;rsquo;y sont lancés.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Multi-plateformes&lt;/strong&gt; : Go intègre aussi nativement la &lt;a href=&#34;https://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5&#34;&gt;compilation croisée&lt;/a&gt;, permettant ainsi de compiler un executable pour une autre architecture que la sienne. Il offre la possibilité de réaliser des &lt;a href=&#34;https://blog.golang.org/c-go-cgo&#34;&gt;appels à du code C&lt;/a&gt;, et ainsi d&amp;rsquo;intégrer des bibliothèques héritées (ou Legacy code) plus facilement.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- Built with concurrency in mind --&gt;

&lt;h2 id=&#34;puissant-mais-perfectible&#34;&gt;Puissant, mais perfectible&lt;/h2&gt;

&lt;p&gt;Malgré tous ses apports, il reste au Go bien des défauts. Certains tiennent plus de choix clivants et d&amp;rsquo;une volonté de rester proche du C/C++, comme son typage fort et le manque d&amp;rsquo;&lt;a href=&#34;https://fr.wikipedia.org/wiki/Inf%C3%A9rence_de_types&#34;&gt;inférence de types&lt;/a&gt;, l&amp;rsquo;absence de paradigme orienté objet, ou encore l&amp;rsquo;usage de pointeurs que nous avons mentionnés plus haut, mais d&amp;rsquo;autres rentrent moins dans cette logique.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Pas de généricité&lt;/strong&gt; : Le défaut le plus évident est le manque de support pour la programmation générique et tout ce qu&amp;rsquo;elle apporte (dont le polymorphisme). Même si les &lt;a href=&#34;http://golangtutorials.blogspot.fr/2011/06/polymorphism-in-go.html&#34;&gt;interfaces&lt;/a&gt; peuvent remplir ce rôle et donc contourner le problème, on y perd grandement en transparence et en propreté du code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mutable ou immutable?&lt;/strong&gt; : Pour des &amp;ldquo;objets&amp;rdquo; complexes (structures, etc.), il n&amp;rsquo;est pas toujours évident de savoir si il sera copié ou modifié. Un objet peut etre passé par adresse et ainsi lever le doute, mais une gestion explicite de l&amp;rsquo;&lt;a href=&#34;https://fr.wikipedia.org/wiki/Objet_immuable&#34;&gt;immutabilité&lt;/a&gt; aurait été un plus bienvenu.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Pas le plus performant&lt;/strong&gt; : Comme mentionné plus haut, le langage Go n&amp;rsquo;est pas toujours le plus performant. Son empreinte mémoire est supérieure à celle de langages tels que C++ ou Scala, et il en va de même pour le temps d&amp;rsquo;exécution ou la taille du binaire généré. Malgré tout, Go reste un langage performant, tout est une question de priorités.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;au-final-ça-en-vaut-la-peine&#34;&gt;Au final, ça en vaut la peine?&lt;/h1&gt;

&lt;p&gt;Le Go peut en rebuter certains par ses choix clivants, mais ses inspirations font de lui un langage simple à apprendre mais profond, et qui apporte de nombreuses récompenses à qui fait l&amp;rsquo;effort de s&amp;rsquo;y investir. Il n&amp;rsquo;a certes pas les performances du C/C++ ou des langages fonctionnels modernes, mais il a pour lui la flexibilité du Python tout en étant plus maintenable et plus strict.&lt;/p&gt;

&lt;p&gt;En tout cas, il semble promis à un bel avenir, en témoigne &lt;a href=&#34;http://www.tiobe.com/tiobe-index/go/&#34;&gt;sa progression&lt;/a&gt;, sa communauté grandissante et son adoption par des grandes companies et services de l&amp;rsquo;Internet, tels que &lt;a href=&#34;http://fr.slideshare.net/jpetazzo/docker-and-go-why-did-we-decide-to-write-docker-in-go&#34;&gt;Docker&lt;/a&gt;, &lt;a href=&#34;https://blogs.dropbox.com/tech/2014/07/open-sourcing-our-go-libraries/&#34;&gt;Dropbox&lt;/a&gt;, &lt;a href=&#34;https://developers.soundcloud.com/blog/go-at-soundcloud&#34;&gt;Soundcloud&lt;/a&gt; ou encore &lt;a href=&#34;https://sendgrid.com/blog/convince-company-go-golang/&#34;&gt;SendGrid&lt;/a&gt;, &lt;a href=&#34;https://github.com/Netflix/rend&#34;&gt;Netflix&lt;/a&gt; et bien d&amp;rsquo;autres.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Pour n&amp;rsquo;en citer qu&amp;rsquo;une, rendre disponible et maintenir un outil pour des cibles n&amp;rsquo;ayant pas d&amp;rsquo;interpréteur python et/ou l&amp;rsquo;ensemble des librairies installées, est un parcours du combattant (pas de cross-compilation possible, nécessité d&amp;rsquo;utiliser des packets spécifiques, exécutables ainsi générés souvent lents et gourmands, etc.).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Le langage Go se situait en 2016 à la 13ème place au &lt;a href=&#34;http://www.tiobe.com/tiobe-index/&#34;&gt;classement Tiobe&lt;/a&gt; des langages les plus utilisés, contre la 54ème en 2015.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Le langage Go est issu des laboratoires de Google et de l&amp;rsquo;esprit de &lt;a href=&#34;https://en.wikipedia.org/wiki/Rob_Pike&#34;&gt;Rob Pike&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;La syntaxe elle-même, proche du style &lt;a href=&#34;https://fr.wikipedia.org/wiki/Style_d&#39;indentation#Style_K.26R&#34;&gt;K&amp;amp;R&lt;/a&gt;, l&amp;rsquo;usage des &lt;a href=&#34;https://blog.golang.org/gos-declaration-syntax&#34;&gt;pointeurs&lt;/a&gt;, etc.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;Pour une liste non exhaustive, on peut se référer &lt;a href=&#34;https://github.com/golang/go/wiki/Projects&#34;&gt;ici&lt;/a&gt;, &lt;a href=&#34;https://github.com/avelino/awesome-go&#34;&gt;là&lt;/a&gt; et &lt;a href=&#34;http://www.mjhall.org/golang-data-science-libraries/&#34;&gt;là-bas&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>